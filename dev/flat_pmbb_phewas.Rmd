---
title: "PMBB Phenome-wide Association Studies"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.

- There already is a dataset in the "inst/" directory to be used in the examples below
-->

```{r development-dataset, eval=FALSE}
# Run all this chunk in the console directly
# There already is a dataset in the "inst/" directory
# Make the dataset file available to the current Rmd during development
pkgload::load_all(path = here::here(), export_all = FALSE)
# 
# # You will be able to read your example data file in each of your function examples and tests as follows - see chunks below
# datafile <- system.file("nyc_squirrels_sample.csv", package = "pmbbPheWASr")
# nyc_squirrels <- read.csv(datafile, encoding = "UTF-8")
# 
# nyc_squirrels
```


# Filter Variant Annotations File

The `awk_str_filter` function can be used to filter arbitrary rows from a tab-delimited text file using `awk`. The function accepts the path to a tab-delimited text file, name of a column to filter, and the string to filter for. The function returns a tibble containing the filtered rows. This function can be used to filter the PMBB variant annotations file to only include variants within the specified gene(s).
    
```{r function-awk_str_filter}
#' Filter arbitrary rows from a tab-delimited text file using awk
#'
#' This function wraps the system command `awk` to efficiently filter rows from a tab-delimited text file. The function accepts the path to a tab-delimited text file, name of a column to filter, and the string to filter for. The function returns a tibble containing the filtered rows.
#'
#' @param filename The path to the tab-delimited text file.
#' @param filter_col The name of the column to filter.
#' @param filter_str A character vector of strings to filter for in the specified column.
#'
#' @return
#'
#' A [tibble::tibble()] containing the filtered rows from the input file
#'
#' @export
#'
awk_str_filter <- function(filename, filter_col, filter_str) {
    # Check if the file exists
    if (!file.exists(filename)) {
        cli::cli_abort("File does not exist: {filename}")
    }
    
    cli::cli_progress_step("Extracting '{filter_str}' from column '{filter_col}' in {.file {filename}}")
  
    # Determine the column index based on the filter_col
    header <- readLines(filename, n = 1)
    col_names <- strsplit(header, "\t")[[1]]
    col_index <- which(col_names == filter_col)

    if (length(col_index) == 0) {
        cli::cli_abort("Column not found: {filter_col}")
    }

    # Construct the awk command
    # awk_cmd <- paste0("awk -F'\t' '", paste0("$", col_index, " ~ /", paste(filter_str, collapse = "|"), "/"), "' ", shQuote(filename))
    
    awk_cmd <- c(paste0("NR == 1 || ", paste0("($", col_index, " == \"", filter_str, "\")", collapse = " || ")), filename)
    
    # Execute the awk command using processx
    result <- processx::run(
        command = "awk",
        args = awk_cmd,
        error_on_status = TRUE
    )

    # Check if the command executed successfully
    if (result$status != 0) {
        cli::cli_abort("Error executing awk command: {result$stderr}")
    }

    # Format the filtered output using data.table::fread()
    filtered_dt <- data.table::fread(
        text = result$stdout,
        sep = "\t",
        header = TRUE,
        stringsAsFactors = FALSE,
        quote = "", 
        na.strings = "."
    )

    # Convert the data.table to a tibble
    filtered_tibble <- tibble::as_tibble(filtered_dt)

    return(filtered_tibble)
}

```
  
```{r example-awk_str_filter}
#' \dontrun{
ldlr_variants <- awk_str_filter(filename = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
               filter_col = "Gene.refGene",
               filter_str = c("LDLR"))
#' }
```
  
```{r tests-awk_str_filter}
test_that("awk_str_filter works", {
  
    ldlr_file <- "ldlr_df.tsv"
  if (!file.exists(ldlr_file)) {
    # The path to use during dev in the flat file
    ldlr_file <- file.path("tests", "testthat", ldlr_file)
    if (!file.exists(ldlr_file)) {
      stop(ldlr_file, " does not exist")
    }
  }

  ldlr_variants <- data.table::fread(ldlr_file)
  
  res <- awk_str_filter(filename = ldlr_file,
               filter_col = "Gene.refGene",
               filter_str = c("LDLR"))
  expect_true(inherits(awk_str_filter, "function")) 
  expect_true(tibble::is_tibble(res))
})
```

# Extract genotypes
    
```{r function-pmbb_extract_genotypes}
#' Extract genotypes from PMBB plink files
#' 
#' This function is a wrapper around `plink2` to extract genotypes from PMBB plink files. The function accepts the path to the plink files and the list of variant IDs to extract. The function returns a long-format [tibble::tibble()] containing the extracted genotypes for each PMBB participant.
#' 
#' @param variant_df A data frame containing the variant information.
#' @param variant_id_col The name of the column in `variant_df` that contains the variant IDs.
#' @param effect_allele_col The name of the column in `variant_df` that contains the effect alleles.
#' @param plink_bin The path to the `plink2` binary executable.
#' @param bfile The prefix of the plink binary files (without the file extension).
#' @param threads The number of threads to use for parallel processing (default: 1).
#' @param memory The amount of memory (in MB) to allocate for `plink2` (default: 8000).
#' 
#' @return A long-format [tibble::tibble()] containing the extracted genotypes for each PMBB participant.
#' 
#' @export
pmbb_extract_genotypes <- function(variant_df, variant_id_col, effect_allele_col, plink_bin, bfile, threads = 1, memory = 8000) {
  
    cli::cli_progress_step("Extracting genotypes from {.file {bfile}}")
  
    allele_file <- fs::file_temp()
    genotype_file <- fs::path(fs::path_temp(), "genotypes")
    
    allele_table <- variant_df %>%
        dplyr::select({{variant_id_col}}, {{effect_allele_col}}) 
    
   allele_table %>%
        data.table::fwrite(allele_file, col.names = FALSE, sep = "\t")
    
    plink_result <- processx::run(
        command = plink_bin,
        args = c(
            "--bfile", bfile,
            "--threads", threads,
            "--memory", memory,
            "--snps", variant_df %>% dplyr::pull({{variant_id_col}}),
            "--export-allele", allele_file,
            "--export", "A",
            "--out", genotype_file
        ),
        error_on_status = TRUE
    )
    
    if (plink_result$status != 0) {
        cli::cli_abort("Error executing plink command. Status: {plink_result$stderr}")
    }
    
    genotype_raw_file <- paste0(genotype_file, ".raw")
    
    if (!file.exists(genotype_raw_file)) {
        cli::cli_abort("Genotype file not found: {genotype_raw_file}")
    }
    
    genotype_df <- data.table::fread(genotype_raw_file)
    
    genotype_tbl <- genotype_df %>%
        tibble::as_tibble() %>%
        tidytable::pivot_longer(cols = -c(`FID`, `IID`, `PAT`, `MAT`, `SEX`, `PHENOTYPE`),
                            names_to = "variant_id",
                            values_to = "genotype") %>%
        dplyr::select(PMBB_ID = IID, variant_id, genotype) %>%
      dplyr::as_tibble()
    
    return(genotype_tbl)
}
```
  
```{r example-pmbb_extract_genotypes}
#' \dontrun{
pmbb_extract_genotypes(variant_df = ldlr_variants,
                       variant_id_col = ID,
                       effect_allele_col = Alt,
                       plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
                       bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL")
#' }
```
  
```{r tests-pmbb_extract_genotypes}
test_that("pmbb_extract_genotypes works", {
  expect_true(inherits(pmbb_extract_genotypes, "function"))
  
  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())
  
  ldlr_file <- "ldlr_df.tsv"
  if (!file.exists(ldlr_file)) {
    # The path to use during dev in the flat file
    ldlr_file <- file.path("tests", "testthat", ldlr_file)
    if (!file.exists(ldlr_file)) {
      stop(ldlr_file, " does not exist")
    }
  }

  ldlr_variants <- data.table::fread(ldlr_file)

  res <- pmbb_extract_genotypes(
    variant_df = ldlr_variants,
    variant_id_col = ID,
    effect_allele_col = Alt,
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
  )
  expect_true(tibble::is_tibble(res))
})
```
    

```{r function-filter_dataframe}
#' Filter a Data Frame Based on Multiple Criteria
#' 
#' This function filters a data frame based on a list of column names and corresponding filter criteria.
#' The filter criteria are provided as a list, where each element represents a column and its associated filter condition.
#' The function applies the filter criteria to the specified columns and returns the filtered data frame.
#' 
#' @param df A data frame to be filtered.
#' @param filter_list A list containing column names and their corresponding filter criteria.
#'   Each element of the list should be named after the column to be filtered and contain the filter condition as a string.
#'   For example: list(age = "> 30", city = "== 'New York'")
#'   
#' @return The filtered [tibble::tibble()] based on the provided filter criteria.
#' 
#' @import dplyr
#' @import rlang
#' @noRd

filter_dataframe <- function(df, filter_list) {
  # Check if the input is a data frame
  if (!is.data.frame(df)) {
    abort("Input must be a data frame.")
  }
  
  # Check if the filter list is a list
  if (!is.list(filter_list)) {
    abort("Filter criteria must be provided as a list.")
  }
  
  # Iterate over each element in the filter list
  for (col_filter in names(filter_list)) {
    # Extract the filter criteria
    filter_criteria <- filter_list[[col_filter]]
    
    # Check if the column exists in the data frame
    if (!(col_filter %in% colnames(df))) {
      warn(glue::glue("Column '{col_filter}' not found in the data frame. Skipping filter for this column."))
      next
    }
    
    # Apply the filter criteria to the specified column using {{}}
    df <- df %>%
      filter(!!parse_expr(paste0({{col_filter}}, filter_criteria)))
  }
  
  return(df)
}
```
  
```{r example-filter_dataframe, eval=FALSE}
#' \dontrun{ 
filter_dataframe(ldlr_variants, filter_list = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"))
#' }
```
  
```{r tests-filter_dataframe}
test_that("filter_dataframe works", {
  res <- filter_dataframe(dplyr::starwars, list(height = " > 100", eye_color = " == 'blue'"))
  expect_true(inherits(filter_dataframe, "function")) 
  expect_true(tibble::is_tibble(res))
  expect_true(nrow(res) > 0)
})
```

# Apply variant masks to annotation file
    
```{r function-apply_variant_masks}
#' Apply variant masks to annotation file
#' 
#' This function applies variant mask criteria to a data frame containing variant annotations. The function can accept multiple sets of filter criteria, each defined as a list of column names and filter conditions. The resulting filtered data frames are returned as a named list.
#' 
#' @param annotation_df A data frame to be filtered.
#' @param masks A named list of lists containing filter criteria.
#'   Each element of the outer list should be named after the desired output name for the filtered data frame (eg. name of the variant mask).
#'   Each inner list should contain the filter criteria for a specific set of columns.
#'   For example: list(plof_0.001 = list(ExonicFunc.ensGene = "= stopgain", gnomAD_exome_ALL = "< 0.001"), common_0.01 = list(gnomAD_exome_ALL = "> 0.01"))
#'   
#' @return A named list of filtered [tibble::tibble()]s based on the provided filter criteria.
#' 
#' @export

apply_variant_masks <- function(annotation_df, masks) {
  # Check if the input is a data frame
  if (!is.data.frame(annotation_df)) {
    rlang::abort("Input must be a data frame.")
  }
  
  # Check if the masks is a list
  if (!is.list(masks)) {
    rlang::abort("Masks must be provided as a list.")
  }
  
  # Apply the filter criteria to the data frame for each mask
  filtered_dfs <- purrr::map(masks, function(mask) {
    filter_dataframe(annotation_df, mask)
  })
  
  # Set the names of the filtered data frames based on the names of the masks
  names(filtered_dfs) <- names(masks)
  
  return(filtered_dfs)
}
```
  
```{r example-apply_variant_masks}
#' \dontrun{ 
apply_variant_masks(ldlr_variants, masks = list(plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"), 
                                                common_0.01 = list(gnomAD_exome_ALL = "> 0.01"), 
                                                exonic_0.001 = list(Func.refGene = "== 'exonic'", gnomAD_exome_ALL = "< 0.001")))
#' }
```
  
```{r tests-apply_variant_masks}
test_that("apply_variant_masks works", {
  expect_true(inherits(apply_variant_masks, "function")) 
})
```
  


  
<!--
# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_pmbb_phewas.Rmd", vignette_name = "Get started")
```

