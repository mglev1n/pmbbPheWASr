---
title: "PMBB Phenome-wide Association Studies"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.

- There already is a dataset in the "inst/" directory to be used in the examples below
-->

```{r development-dataset, eval=FALSE}
# Run all this chunk in the console directly
# There already is a dataset in the "inst/" directory
# Make the dataset file available to the current Rmd during development
pkgload::load_all(path = here::here(), export_all = FALSE)
# 
# # You will be able to read your example data file in each of your function examples and tests as follows - see chunks below
# datafile <- system.file("nyc_squirrels_sample.csv", package = "pmbbPheWASr")
# nyc_squirrels <- read.csv(datafile, encoding = "UTF-8")
# 
# nyc_squirrels
```


# Filter Variant Annotations File

The `awk_str_filter` function can be used to filter arbitrary rows from a tab-delimited text file using `awk`. The function accepts the path to a tab-delimited text file, name of a column to filter, and the string to filter for. The function returns a tibble containing the filtered rows. This function can be used to filter the PMBB variant annotations file to only include variants within the specified gene(s).
    
```{r function-awk_str_filter}
#' Filter arbitrary rows from a tab-delimited text file using awk
#'
#' This function wraps the system command `awk` to efficiently filter rows from a tab-delimited text file. The function accepts the path to a tab-delimited text file, name of a column to filter, and the string to filter for. The function returns a tibble containing the filtered rows.
#'
#' @param filename The path to the tab-delimited text file.
#' @param filter_col The name of the column to filter.
#' @param filter_str A character vector of strings to filter for in the specified column.
#'
#' @return
#'
#' A [tibble::tibble()] containing the filtered rows from the input file
#'
#' @export
#'
awk_str_filter <- function(filename, filter_col, filter_str) {
    # Check if the file exists
    if (!file.exists(filename)) {
        cli::cli_abort("File does not exist: {filename}")
    }
    
    cli::cli_progress_step("Extracting '{filter_str}' from column '{filter_col}' in {.val {filename}}")
  
    # Determine the column index based on the filter_col
    header <- readLines(filename, n = 1)
    col_names <- strsplit(header, "\t")[[1]]
    col_index <- which(col_names == filter_col)

    if (length(col_index) == 0) {
        cli::cli_abort("Column not found: {filter_col}")
    }

    # Construct the awk command
    # awk_cmd <- paste0("awk -F'\t' '", paste0("$", col_index, " ~ /", paste(filter_str, collapse = "|"), "/"), "' ", shQuote(filename))
    
    awk_cmd <- c(paste0("NR == 1 || ", paste0("($", col_index, " == \"", filter_str, "\")", collapse = " || ")), filename)
    
    # Execute the awk command using processx
    result <- processx::run(
        command = "awk",
        args = awk_cmd,
        error_on_status = TRUE
    )

    # Check if the command executed successfully
    if (result$status != 0) {
        cli::cli_abort("Error executing awk command: {result$stderr}")
    }

    # Format the filtered output using data.table::fread()
    filtered_dt <- data.table::fread(
        text = result$stdout,
        sep = "\t",
        header = TRUE,
        stringsAsFactors = FALSE,
        quote = "", 
        na.strings = "."
    )

    # Convert the data.table to a tibble
    filtered_tibble <- tibble::as_tibble(filtered_dt)

    return(filtered_tibble)
}

```
  
```{r example-awk_str_filter, eval=FALSE}
#' \dontrun{
ldlr_variants <- awk_str_filter(
  filename = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  filter_col = "Gene.refGene",
  filter_str = c("LDLR"))
#' }
```
  
```{r tests-awk_str_filter}
test_that("awk_str_filter works", {
  
    ldlr_file <- "ldlr_df.tsv"
  if (!file.exists(ldlr_file)) {
    # The path to use during dev in the flat file
    ldlr_file <- file.path("tests", "testthat", ldlr_file)
    if (!file.exists(ldlr_file)) {
      stop(ldlr_file, " does not exist")
    }
  }

  ldlr_variants <- data.table::fread(ldlr_file)
  
  res <- awk_str_filter(filename = ldlr_file,
               filter_col = "Gene.refGene",
               filter_str = c("LDLR"))
  expect_true(inherits(awk_str_filter, "function")) 
  expect_true(tibble::is_tibble(res))
})
```

# Apply variant masks to annotation file
    
The `apply_variant_masks` function applies variant mask criteria to a data frame containing variant annotations. The function can accept multiple sets of filter criteria, each defined as a list of column names and filter conditions. The resulting filtered data frames are returned as a named list.

```{r function-apply_variant_masks}
#' Apply variant masks to annotation file
#' 
#' This function applies variant mask criteria to a data frame containing variant annotations. The function can accept multiple sets of filter criteria, each defined as a list of column names and filter conditions. The resulting filtered data frames are returned as a named list.
#' 
#' @param annotation_df A data frame to be filtered.
#' @param masks A named list of lists containing filter criteria.
#'   Each element of the outer list should be named after the desired output name for the filtered data frame (eg. name of the variant mask).
#'   Each inner list should contain the filter criteria for a specific set of columns.
#'   For example: list(plof_0.001 = list(ExonicFunc.ensGene = "= stopgain", gnomAD_exome_ALL = "< 0.001"), common_0.01 = list(gnomAD_exome_ALL = "> 0.01"))
#'   
#' @return A named list of filtered [tibble::tibble()]s based on the provided filter criteria.
#' 
#' @export

apply_variant_masks <- function(annotation_df, masks) {
  # Check if the input is a data frame
  if (!is.data.frame(annotation_df)) {
    rlang::abort("Input must be a data frame.")
  }
  
  # Check if the masks is a list
  if (!is.list(masks)) {
    rlang::abort("Masks must be provided as a list.")
  }
  
  # Apply the filter criteria to the data frame for each mask
  filtered_dfs <- purrr::map(masks, function(mask) {
    list(variants = filter_dataframe(annotation_df, mask),
         mask = deparse(mask))
  })
  
  # Set the names of the filtered data frames based on the names of the masks
  names(filtered_dfs) <- names(masks)
  
  return(filtered_dfs)
}
```
  
```{r example-apply_variant_masks, eval=FALSE}
#' \dontrun{

# Extract variants in a gene
ldlr_variants <- awk_str_filter(
  filename = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  filter_col = "Gene.refGene",
  filter_str = c("LDLR"))

# Apply the specified masks to the set of variants
apply_variant_masks(
  ldlr_variants,
  masks = list(
    plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"),
    common_0.01 = list(gnomAD_exome_ALL = "> 0.01"),
    exonic_0.001 = list(Func.refGene = "== 'exonic'", gnomAD_exome_ALL = "< 0.001")
  )
)
#' }
```
  
```{r tests-apply_variant_masks}
test_that("apply_variant_masks works", {
  expect_true(inherits(apply_variant_masks, "function")) 
})
```

```{r function-filter_dataframe}
#' Filter a Data Frame Based on Multiple Criteria
#' 
#' This function filters a data frame based on a list of column names and corresponding filter criteria.
#' The filter criteria are provided as a list, where each element represents a column and its associated filter condition.
#' The function applies the filter criteria to the specified columns and returns the filtered data frame.
#' 
#' @param df A data frame to be filtered.
#' @param filter_list A list containing column names and their corresponding filter criteria.
#'   Each element of the list should be named after the column to be filtered and contain the filter condition as a string.
#'   For example: list(age = "> 30", city = "== 'New York'")
#'   
#' @return The filtered [tibble::tibble()] based on the provided filter criteria.
#' 
#' @import dplyr
#' @import rlang
#' @noRd

filter_dataframe <- function(df, filter_list) {
  # Check if the input is a data frame
  if (!is.data.frame(df)) {
    abort("Input must be a data frame.")
  }
  
  # Check if the filter list is a list
  if (!is.list(filter_list)) {
    abort("Filter criteria must be provided as a list.")
  }
  
  # Iterate over each element in the filter list
  for (col_filter in names(filter_list)) {
    # Extract the filter criteria
    filter_criteria <- filter_list[[col_filter]]
    
    # Check if the column exists in the data frame
    if (!(col_filter %in% colnames(df))) {
      warn(glue::glue("Column '{col_filter}' not found in the data frame. Skipping filter for this column."))
      next
    }
    
    # Apply the filter criteria to the specified column using {{}}
    df <- df %>%
      filter(!!parse_expr(paste0({{ col_filter }}, filter_criteria)))
  }
  
  return(df)
}
```
  
```{r example-filter_dataframe, eval=FALSE, include=FALSE}
#' \dontrun{
filter_dataframe(
  ldlr_variants, 
  filter_list = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"))
#' }
```
  
```{r tests-filter_dataframe}
test_that("filter_dataframe works", {
  res <- filter_dataframe(dplyr::starwars, list(height = " > 100", eye_color = " == 'blue'"))
  expect_true(inherits(filter_dataframe, "function")) 
  expect_true(tibble::is_tibble(res))
  expect_true(nrow(res) > 0)
})
```


# Extracting genotypes

## Extract a single set of variants

The `pmbb_extract_genotypes` function is a wrapper around `plink2` to extract genotypes from PMBB plink files. The function accepts the path to the plink files and the list of variant IDs to extract. The function returns a long-format tibble containing the extracted genotypes for each PMBB participant.

```{r function-pmbb_extract_genotypes}
#' Extract genotypes from PMBB plink files
#' 
#' This function is a wrapper around `plink2` to extract genotypes from PMBB plink files. The function accepts the path to the plink files and the list of variant IDs to extract. The function returns a long-format [tibble::tibble()] containing the extracted genotypes for each PMBB participant.
#' 
#' @param variant_df A data frame containing the variant information.
#' @param variant_id_col The name of the column in `variant_df` that contains the variant IDs.
#' @param effect_allele_col The name of the column in `variant_df` that contains the effect alleles.
#' @param plink_bin The path to the `plink2` binary executable.
#' @param bfile The prefix of the plink binary files (without the file extension).
#' @param threads The number of threads to use for parallel processing (default: 1).
#' @param memory The amount of memory (in MB) to allocate for `plink2` (default: 8000).
#' 
#' @return A long-format [tibble::tibble()] containing the extracted genotypes for each PMBB participant.
#' 
#' @export
pmbb_extract_genotypes <- function(variant_df, variant_id_col, effect_allele_col, plink_bin, bfile, threads = 1, memory = 8000) {
  
    cli::cli_progress_step("Extracting genotypes from {.val {bfile}}")
  
    allele_file <- fs::file_temp()
    genotype_file <- fs::path(fs::path_temp(), "genotypes")
    
    allele_table <- variant_df %>%
        dplyr::select(!!ensym(variant_id_col), !!ensym(effect_allele_col))
    
   allele_table %>%
        data.table::fwrite(allele_file, col.names = FALSE, sep = "\t")
    
    plink_result <- processx::run(
        command = plink_bin,
        args = c(
            "--bfile", bfile,
            "--threads", threads,
            "--memory", memory,
            "--snps", variant_df %>% dplyr::pull(!!ensym(variant_id_col)),
            "--export-allele", allele_file,
            "--export", "A",
            "--out", genotype_file
        ),
        error_on_status = TRUE
    )
    
    if (plink_result$status != 0) {
        cli::cli_abort("Error executing plink command. Status: {plink_result$stderr}")
    }
    
    genotype_raw_file <- paste0(genotype_file, ".raw")
    
    if (!file.exists(genotype_raw_file)) {
        cli::cli_abort("Genotype file not found: {genotype_raw_file}")
    }
    
    genotype_df <- data.table::fread(genotype_raw_file)
    
    genotype_tbl <- genotype_df %>%
        tibble::as_tibble() %>%
        tidytable::pivot_longer(cols = -c(`FID`, `IID`, `PAT`, `MAT`, `SEX`, `PHENOTYPE`),
                            names_to = "variant_id",
                            values_to = "genotype") %>%
        dplyr::select(PMBB_ID = IID, variant_id, genotype) %>%
      dplyr::as_tibble()
    
    return(genotype_tbl)
}
```
  
```{r example-pmbb_extract_genotypes, eval=FALSE}
#' \dontrun{
pmbb_extract_genotypes(
  variant_df = ldlr_variants,
  variant_id_col = ID,
  effect_allele_col = Alt,
  plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
  bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
)
#' }
```
  
```{r tests-pmbb_extract_genotypes}
test_that("pmbb_extract_genotypes works", {
  expect_true(inherits(pmbb_extract_genotypes, "function"))
  
  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())
  
  ldlr_file <- "ldlr_df.tsv"
  if (!file.exists(ldlr_file)) {
    # The path to use during dev in the flat file
    ldlr_file <- file.path("tests", "testthat", ldlr_file)
    if (!file.exists(ldlr_file)) {
      stop(ldlr_file, " does not exist")
    }
  }

  ldlr_variants <- data.table::fread(ldlr_file)

  ldlr_genotype_res <- pmbb_extract_genotypes(
    variant_df = ldlr_variants,
    variant_id_col = ID,
    effect_allele_col = Alt,
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
  )
  expect_true(tibble::is_tibble(ldlr_genotype_res))
})
```

## Extract genotypes based on masks 

The `pmbb_extract_genotype_masks` function extracts genotypes for a subset of participants based on a set of masks. This function wraps `awk_str_filter`, `apply_variant_masks`, and `pmbb_extract_genotypes` to extract genotypes for PMBB participants based on a set of masks. 
    

```{r function-pmbb_extract_genotype_masks}
#' Extract genotypes based on variant masks
#' 
#' This function extracts genotypes for a subset of participants based on a set of masks. It wraps `awk_str_filter`, `apply_variant_masks`, and `pmbb_extract_genotypes` to extract genotypes for PMBB participants based on a set of masks.
#' 
#' @param annotation_file The path to the variant annotation file.
#' @param gene The name of the gene to filter variants for.
#' @param gene_col The name of the column in the annotation file to filter the gene on.
#' @param masks A named list of lists containing filter criteria for each mask.
#'   Each element of the outer list should be named after the desired output name for the filtered data frame (eg. name of the variant mask).
#'   Each inner list should contain the filter criteria for a specific set of columns.
#'   For example: list(plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"), common_0.01 = list(gnomAD_exome_ALL = "> 0.01"))
#' @param variant_id_col The name of the column in the annotation file that contains the variant IDs.
#' @param effect_allele_col The name of the column in the annotation file that contains the effect alleles.
#' @param mask_operator A named list specifying the operation to perform for each mask. Valid operations are "burden" (default) and "single".
#'   The names in the mask_operator list should correspond to the names in the masks list.
#'   For example: list(plof_0.001 = "burden", common_0.01 = "single")
#' @param plink_bin The path to the `plink2` binary executable.
#' @param bfile The prefix of the plink binary files (without the file extension).
#' @param threads The number of threads to use for parallel processing (default: 1).
#' @param memory The amount of memory (in MB) to allocate for `plink2` (default: 8000).
#' 
#' @return A named list, where each element represents a mask and contains a list with components based on the specified mask_operator:
#'          - "variants": A [tibble::tibble()] of the variants included in the mask.
#'          - "genotypes": A [tibble::tibble()] containing the genotype for each PMBB participant.
#'          - "mask": A string containing the mask applied to filter the variants.
#'          - "mask_type": A [tibble::tibble()] containing the mask type applied (eg. "burden" or "single").
#' @export

pmbb_extract_genotype_masks <- function(gene, annotation_file, gene_col, masks, variant_id_col, effect_allele_col, mask_operator = NULL, plink_bin, bfile, threads = 1, memory = 8000) {
    
    # Check if the names in the mask_operator list are present in the masks list
    if (!is.null(mask_operator) && !all(names(mask_operator) %in% names(masks))) {
      missing_masks <- setdiff(names(mask_operator), names(masks))
      cli::cli_abort("The following mask operators are not present in the masks list: {missing_masks}")
    }
    
    cli::cli_progress_step("Filtering variants for gene: {.val {gene}}")
    
    gene_variants <- awk_str_filter(
      filename = annotation_file,
      filter_col = gene_col, 
      filter_str = gene
    )
    
    cli::cli_progress_step("Applying variant masks")
    
    masked_variants <- apply_variant_masks(gene_variants, masks)
    
    cli::cli_progress_step("Extracting unique set of variant IDs across all masks")
    
    unique_variant_ids <- masked_variants %>%
      purrr::map(\(x) purrr::pluck(x, "variants") %>% dplyr::pull(!!ensym(variant_id_col))) %>%
      purrr::reduce(union)
    
    cli::cli_progress_step("Extracting genotypes for unique set of variant IDs")
    
    genotype_df <- pmbb_extract_genotypes(
      variant_df = gene_variants %>% dplyr::filter(!!ensym(variant_id_col) %in% unique_variant_ids),
      variant_id_col = !!ensym(variant_id_col),
      effect_allele_col = !!ensym(effect_allele_col),
      plink_bin = plink_bin,
      bfile = bfile,
      threads = threads,
      memory = memory
    )
    
    cli::cli_progress_step("Processing genotypes for each variant mask")
    
    mask_list <- purrr::imap(masked_variants, function(variant_list, mask_name) {
      mask_genotypes <- genotype_df %>%
        dplyr::mutate(ID = stringr::str_replace(variant_id, "_[^_]+$", "")) %>%
        dplyr::filter(ID %in% (variant_list %>% purrr::pluck("variants") %>% dplyr::pull(!!ensym(variant_id_col))))
      
      if (is.null(mask_operator) || mask_operator[[mask_name]] == "burden") {
        mask_genotypes_summarized <- mask_genotypes %>%
          dplyr::group_by(PMBB_ID) %>%
          dplyr::summarize(genotype = sum(genotype, na.rm = TRUE), .groups = "drop") %>%
          dplyr::select(dplyr::everything(), genotype)
        
        list(variants = variant_list %>% purrr::pluck("variants") %>% filter(!!ensym(variant_id_col) %in% mask_genotypes$ID),
             genotypes = mask_genotypes_summarized,
             mask = variant_list %>% purrr::pluck("mask"),
             mask_type = "burden")
        
      } else if (mask_operator[[mask_name]] == "single") {
        purrr::map(unique(mask_genotypes$variant_id), function(variant) {
          variant_genotypes <- mask_genotypes %>% 
            dplyr::filter(variant_id == variant) %>%
            dplyr::select(dplyr::everything(), genotype)
          
          list(
            name = paste(mask_name, variant, sep = "_"),
            variants = variant_list %>% purrr::pluck("variants") %>% dplyr::filter(!!ensym(variant_id_col) == stringr::str_replace(variant, "_[^_]+$", "")),
            genotypes = variant_genotypes,
            mask = variant_list %>% purrr::pluck("mask"),
            mask_type = "single"
          )
        })
      }
    })
    
    # Set the names of the mask_list for burden masks
    burden_mask_names <- names(mask_operator)[mask_operator == "burden"]
    names(mask_list)[names(mask_list) %in% burden_mask_names] <- burden_mask_names
    
    # Flatten the single-variant masks and set their names
    single_mask_list <- purrr::flatten(mask_list[names(mask_list) %in% names(mask_operator)[mask_operator == "single"]])
    names(single_mask_list) <- purrr::map_chr(single_mask_list, "name")
    single_mask_list <- purrr::map(single_mask_list, ~ purrr::keep(.x, names(.x) %in% c("variants", "genotypes", "mask", "mask_type")))
    
    # Combine the burden and single-variant masks into the final mask_list
    final_mask_list <- c(mask_list[names(mask_list) %in% burden_mask_names], single_mask_list)
    
    return(final_mask_list)
}
```


  
```{r example-pmbb_extract_genotype_masks, eval=FALSE}
#' \dontrun{
ldlr_mask_res <- pmbb_extract_genotype_masks(
  gene = "LDLR",
  annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  gene_col = "Gene.refGene",
  masks = list(
    plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"),
    rare_0.000001 = list(gnomAD_exome_ALL = "< 0.000001")
  ),
  mask_operator = list(
    plof_0.001 = "burden",
    rare_0.000001 = "single"
  ),
  variant_id_col = ID,
  effect_allele_col = Alt,
  plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
  bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL")
#' }
```
  
```{r tests-pmbb_extract_genotype_masks}
test_that("pmbb_extract_genotype_masks works", {
  expect_true(inherits(pmbb_extract_genotype_masks, "function"))

  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())

  ldlr_mask_res <- pmbb_extract_genotype_masks(
    gene = "LDLR",
    annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
    gene_col = "Gene.refGene",
    masks = list(
      plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"),
      rare_0.000001 = list(gnomAD_exome_ALL = "< 0.000001")
    ),
    mask_operator = list(
      plof_0.001 = "burden",
      rare_0.000001 = "single"
    ),
    variant_id_col = ID,
    effect_allele_col = Alt,
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
  )
  
  expect_type(ldlr_mask_res, "list")
  expect_equal(ldlr_mask_res$plof_0.001$mask_type, "burden")
})
```

# PheWAS convenience functions

## Format PMBB phecode data

The `pmbb_format_phecodes` function takes a path to a PMBB phecode file and applies a case threshold to categorize individuals as cases or controls. The function returns a tibble with `PMBB_ID` and phecodes as columns, with TRUE/FALSE values for each phecode column.
    
```{r function-pmbb_format_phecodes}
#' Format PMBB phecode data
#' 
#' Given a dataframe containing PMBB phecodes, apply a case treshold for categorizing individuals as cases or controls
#' 
#' @param phecode_file Path to PMBB phecode file used to run PheWAS
#' @param phecode_case_threshold Number of cases required to classify an individual as a case
#'
#' @return A [tibble::tibble()] containing `PMBB_ID` and phecodes as columns, with TRUE/FALSE values for each phecode column
#' 
#' @export

pmbb_format_phecodes <- function(phecode_file, phecode_case_threshold = 2){
    cli::cli_progress_step("Formatting {phecode_file}")
  
  vroom::vroom(phecode_file, show_col_types = FALSE) %>%
    tidytable::pivot_longer(cols = c(-PMBB_ID)) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(case = dplyr::if_else(value >= phecode_case_threshold, TRUE, FALSE)) %>%
    tidytable::select(PMBB_ID, name, case) %>%
    tidytable::pivot_wider(names_from = name, values_from = case, values_fill = FALSE) %>%
    tibble::as_tibble() %>%
    # unique() %>%
    assertr::assert(assertr::is_uniq, PMBB_ID)
}
```
  
```{r example-pmbb_format_phecodes, eval=FALSE}
#' \dontrun{
pmbb_format_phecodes(phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt")
#' }

```
  
```{r tests-pmbb_format_phecodes}
test_that("pmbb_format_phecodes works", {
  expect_true(inherits(pmbb_format_phecodes, "function"))
  phecode_file <- "phecodes.tsv"
  if (!file.exists(phecode_file)) {
    # The path to use during dev in the flat file
    phecode_file <- file.path("tests", "testthat", phecode_file)
    if (!file.exists(phecode_file)) {
      stop(phecode_file, " does not exist")
    }
  }

  res <- pmbb_format_phecodes(phecode_file)
  expect_true(tibble::is_tibble(res))
})
```
  

    
```{r function-pmbb_format_covariates}
#' Format covariate data for PheWAS
#'
#' This function reads and processes covariate files for use in PheWAS analysis.It checks if the specified covariate files exist, reads them, and performs the necessary data formatting and validation. If multiple files are specified they will be joined together from left-to-right, keeping duplicated columns from the left-most file.
#'
#' @param covariate_files Path to PMBB covariate file(s) used to run PheWAS. If multiple files are provided, they will be joined by `PMBB_ID`, and values for duplicated columns will be preserved from the from the file that is specified earlier.
#' @param covariate_cols Vector of columns in the covariate file that should be used as covariates in the PheWAS
#' @param covariate_population_col Column containing population labels in the covariate file, required if `populations` is not `"ALL"`
#' @param populations A character vector of populations to run PheWAS on. Default is `c("ALL")`
#'
#' @return A formatted covariate dataframe with selected columns and unique PMBB_IDs.
#'
#' 
#' @noRd
pmbb_format_covariates <- function(covariate_files, covariate_cols, covariate_population_col, populations) {
  
  # Check if covariate_files exists - this may include multiple files
  covariate_files_exists <- purrr::map(covariate_files, file.exists) %>%
    unlist()

  if (FALSE %in% purrr::map(covariate_files, file.exists)) {
    missing_covariates_files <- covariate_files[!covariate_files_exists]
    cli::cli_abort("{missing_covariates_files} does not exist")
  }
  
  # Check if populations is a character vector
  if (!is.character(populations)) {
    cli::cli_abort("{.arg populations} must be a character vector")
  }

  # Check if populations contains values other than "ALL"
  populations <- unique(populations)
  if (length(sum(stringr::str_detect(populations, "ALL")))/length(populations) != 1) {
    if(rlang::quo_is_null(rlang::enquo(covariate_population_col))) {
      cli::cli_abort("{.arg covariate_population_col} must be provided if {.arg populations} contains values other than {.val ALL}")
    }
  }

  cli::cli_progress_step("Reading covariate file(s): {covariate_files}")

  covariate_df <- purrr::map(covariate_files, \(x) vroom::vroom(x, show_col_types = FALSE) %>% unique()) %>%
    purrr::reduce(dplyr::left_join, by = c("PMBB_ID"), suffix = c("", "_duplicated")) %>%
    dplyr::select(-tidyselect::ends_with("_duplicated")) %>%
    unique()

  if (!rlang::quo_is_null(rlang::enquo(covariate_population_col))) {

    # TODO need better checking that the covariate_population_col is in the covariate_df

    covariate_populations <- unique(covariate_df %>% dplyr::pull({{ covariate_population_col }}))
    missing_populations <- setdiff(populations, covariate_populations)
    missing_populations <- purrr::discard(missing_populations, function(x) x == "ALL")

    if(length(missing_populations > 0)) {
      cli::cli_abort("Population(s) {.val {missing_populations}} not found in covariate file")
    }

    cli::cli_alert_info("All populations were found in the covariates file")
  }

  covariate_df %>%
    dplyr::select(PMBB_ID, {{ covariate_cols }}, !!ensym(covariate_population_col)) %>%
    assertr::assert(assertr::is_uniq, PMBB_ID)

}
```
  
```{r example-pmbb_format_covariates, eval=FALSE, include=FALSE}
#' \dontrun{
pmbb_format_covariates(
  covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
  populations = c("ALL", "EUR"),
  covariate_population_col = Class,
  covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC"))
)
#' }

```
  
```{r tests-pmbb_format_covariates}
test_that("pmbb_format_covariates works", {
  expect_true(inherits(pmbb_format_covariates, "function")) 
  
  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())
  
  pmbb_covariates_res <- pmbb_format_covariates(
  covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
  populations = c("ALL", "EUR"),
  covariate_population_col = Class,
  covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC"))
)
  
  expect_true(inherits(pmbb_covariates_res, "data.frame"))
  
})
```
  

## Run a PheWAS

The `run_pmbb_phewas` function runs a PheWAS on the PMBB data, using the results of the `pmbb_extract_genotype_masks` function and paths to PMBB files containing phenotype and covariate data. 
    
```{r function-run_pmbb_phewas}
#' Run a PheWAS on PMBB data
#' 
#' This function runs a PheWAS on PMBB data, using genotype information and paths to PMBB files containing phenotype and covariate data. The function ideally accepts genotype information from the `pmbb_extract_genotype_masks` function, but can accept any genotype information of the format `list(mask_name = list(genotypes = data.frame(PMBB_ID = character(), genotype = character())))`
#' 
#' @param mask_genotypes_list A named list, where each element contains a named element called `genotypes` which contains `PMBB_ID` and `genotype` columns.
#' @param phecode_file Path to PMBB phenotype file or a dataframe containing phenotype data used to run PheWAS
#' @param covariate_files Path to PMBB covariate file(s) or a dataframe containing covariate data used to run PheWAS. If multiple files are provided, they will be joined by `PMBB_ID`, and values for duplicated columns will be preserved from the from the file that is specified earlier.
#' @param populations A character vector of populations to run PheWAS on. Default is `c("ALL")`
#' @param covariate_cols Vector of columns in the covariate file or dataframe that should be used as covariates in the PheWAS
#' @param covariate_population_col Column containing population labels in the covariate file or dataframe, required if `populations` is not `ALL`
#' @param phenotype_case_count The minimum number of codes required to be considered a case (Default: 2)
#' @param ... Additional arguments passed to [PheWAS::phewas()]

#' @return A [tibble::tibble()] containing the results of the PheWAS for each population and mask
#' 
#' @export
run_pmbb_phewas <- function(mask_genotypes_list, phecode_file, covariate_files, populations = c("ALL"), covariate_cols, covariate_population_col = NULL, phenotype_case_count = 2, ...) {
  # Check if mask_genotypes_list is a list
  if (!is.list(mask_genotypes_list)) {
    cli::cli_abort("{.arg mask_genotypes_list} must be a list")
  }

  # Check if phenotype_file is a file path or a dataframe
  if (is.character(phecode_file)) {
    if (!file.exists(phecode_file)) {
      cli::cli_abort("{phenotype_file} does not exist")
    }
    phecode_df <- pmbb_format_phecodes(phecode_file, phenotype_case_count)
  } else if (is.data.frame(phecode_file)) {
    phecode_df <- phecode_file
  } else {
    cli::cli_abort("{.arg phecode_file} must be a file path or a dataframe")
  }

  # Format covariate data
  if (is.character(covariate_files)) {
    covariate_df <- pmbb_format_covariates(covariate_files, {{ covariate_cols }}, !!ensym(covariate_population_col), populations)
  } else if (is.data.frame(covariate_files)) {
    covariate_df <- covariate_files
  } else {
    cli::cli_abort("{.arg covariate_files} must be file paths or a dataframe")
  }

  # Run PheWAS
  cli::cli_progress_step("Running PheWAS")

  phewas_combos <- tidyr::expand_grid(genotype_masks = mask_genotypes_list, population = populations) %>%
    dplyr::mutate(mask_name = purrr::imap(genotype_masks, ~.y)) %>%
    tidyr::unnest(mask_name)

  phewas_res_list <- purrr::pmap(phewas_combos, \(genotype_masks, population, mask_name) {
    if (population != "ALL") {
      covariate_df <- covariate_df %>%
        dplyr::filter(!!ensym(covariate_population_col) == population) %>%
        dplyr::select(-!!ensym(covariate_population_col))
    } else {
      covariate_df <- covariate_df %>%
        dplyr::select(-!!ensym(covariate_population_col))
    }

    allele_counts <- genotype_masks %>%
      purrr::pluck("genotypes") %>%
      count(genotype)

    additive <- dplyr::if_else(genotype_masks %>% purrr::pluck("mask_type") == "single", TRUE, FALSE)

    phewas_res <- PheWAS::phewas(
      genotypes = genotype_masks %>% purrr::pluck("genotypes"),
      phenotypes = phecode_df,
      covariates = covariate_df,
      # additive.genotypes = additive,
      ...
    )

    dplyr::tibble(
      mask_name = mask_name,
      population = population,
      allele_counts = list(allele_counts),
      covariates = list(names(covariate_df %>% dplyr::select(-PMBB_ID))),
      phewas_res
    )
  }) %>%
    purrr::list_rbind()

  return(phewas_res_list)
}
```
  
```{r example-run_pmbb_phewas, eval=FALSE}
#' \dontrun{
# Extract genotypes for a series of masks
ldlr_mask_res <- pmbb_extract_genotype_masks(
  gene = "LDLR",
  annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  gene_col = "Gene.refGene",
  masks = list(
    plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"),
    common = list(gnomAD_exome_ALL = "> 0.01")
  ),
  mask_operator = list(
    plof_0.001 = "burden",
    common = "single"
  ),
  variant_id_col = ID,
  effect_allele_col = Alt,
  plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
  bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL")

# Run a PheWAS
phewas_res <- run_pmbb_phewas(
  mask_genotypes_list = ldlr_mask_res,
  phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt",
  covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
  populations = c("ALL", "EUR"),
  covariate_population_col = Class,
  covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC"))
)
#' }
```
  
```{r tests-run_pmbb_phewas}
test_that("run_pmbb_phewas works", {
  expect_true(inherits(run_pmbb_phewas, "function"))

  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())

  ldlr_mask_res <- pmbb_extract_genotype_masks(
    gene = "LDLR",
    annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
    gene_col = "Gene.refGene",
    masks = list(
      plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"),
      rare_0.000001 = list(gnomAD_exome_ALL = "< 0.000001")
    ),
    mask_operator = list(
      plof_0.001 = "burden",
      rare_0.000001 = "single"
    ),
    variant_id_col = ID,
    effect_allele_col = Alt,
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
  )

  pmbb_phecodes <- pmbb_format_phecodes(phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt")
  
  suppressWarnings(
    phewas_res <- run_pmbb_phewas(
      mask_genotypes_list = ldlr_mask_res %>% head(2),
      phecode_file = pmbb_phecodes %>% dplyr::select(1:5) %>% head(100),
      covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
      populations = c("ALL", "EUR"),
      covariate_population_col = "Class",
      covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC"))
    )
  )

  expect_true(inherits(phewas_res, "data.frame"))
})
```

## Run a PheWAS and generate a report

The `run_pmbb_phewas_report` function is a wrapper around the `run_pmbb_phewas` function that generates an HTML report of the results.

```{r function-run_pmbb_phewas_report}
#' Run a PheWAS and generate a report
#' 
#' This function is a wrapper around the `run_pmbb_phewas` function that additionally generates an HTML report of the results.
#' 
#' @param report_output_path (Optional) File name and path were the report should be saved. If not provided the report will be saved to the current directory
#' @inheritParams run_pmbb_phewas
#' @inheritParams pmbb_extract_genotype_masks
#' @inheritParams render_pmbb_phewas_report
#' 
#' @return A named list containing the paths to the output files
#' 
#' @export
run_pmbb_phewas_report <- function(gene, annotation_file, gene_col, masks, mask_operator, variant_id_col, effect_allele_col, plink_bin, bfile, phecode_file, covariate_files, populations, covariate_population_col, covariate_cols, mask_output_path = NULL, phewas_output_path = NULL, report_output_path = NULL, ...) {
  
  # Extract genotypes for a series of masks
  mask_res <- pmbb_extract_genotype_masks(
    gene = gene,
    annotation_file = annotation_file,
    gene_col = gene_col,
    masks = masks,
    mask_operator = mask_operator,
    variant_id_col = {{ variant_id_col }},
    effect_allele_col = {{ effect_allele_col }},
    plink_bin = plink_bin,
    bfile = bfile
  )
  
  # Save the mask results to a file
  if (is.null(mask_output_path)) {
    # Use a temporary file if mask_output_path is not provided
    mask_output_path <- tempfile(fileext = ".rds")
  }
  saveRDS(mask_res, file = mask_output_path)
  
  # Run a PheWAS
  phewas_res <- run_pmbb_phewas(
    mask_genotypes_list = mask_res,
    phecode_file = phecode_file,
    covariate_files = covariate_files,
    populations = populations,
    covariate_population_col = {{ covariate_population_col }},
    covariate_cols = {{ covariate_cols }},
    ...
  )
  
  # Save the PheWAS results to a file
  if (is.null(phewas_output_path)) {
    # Use a temporary file if phewas_output_path is not provided
    phewas_output_path <- tempfile(fileext = ".rds")
  }
  saveRDS(phewas_res, file = phewas_output_path)
  
  # Collapse the gene names into a single string
  gene_names_collapsed <- glue::glue_collapse(gene, sep = "-")
  
  # Generate a timestamp for the output file name
  timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")
  
  # Generate the output file name with the timestamp and collapsed gene names
  output_file <- paste0(gene_names_collapsed, "_", "phewas_report_", timestamp,".html")
  
  # Set the full output file path
  if (!is.null(report_output_path)) {
    output_file <- fs::path(report_output_path, output_file)
  }
  
  # Render the PheWAS report
  render_pmbb_phewas_report(
    mask_output_path = mask_output_path,
    phewas_output_path = phewas_output_path,
    output_file = output_file
  )
  
  # Return the paths to the saved mask, PheWAS results, and report files
  return(list(
    report_output_path = output_file,
    mask_output_path = mask_output_path,
    phewas_output_path = phewas_output_path
  ))
}
```
  
```{r example-run_pmbb_phewas_report, eval=FALSE}
#' \dontrun{
run_pmbb_phewas_report(
  gene = c("LDLR"),
  annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  gene_col = "Gene.refGene",
  masks = list(
    plof_0.01 = list(ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", gnomAD_exome_ALL = "< 0.01"),
    missense_0.01 = list(ExonicFunc.ensGene = "%in% c('nonsynonymous SNV')", gnomAD_exome_ALL = "< 0.01")
  ),
  mask_operator = list(
    plof_0.01 = "burden",
    missense_0.01 = "burden"
  ),
  variant_id_col = ID,
  effect_allele_col = Alt,
  populations = c("ALL"),
  covariate_population_col = "Class",
  covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC")),
  mask_output_path = "LDLR_mask_results.rds",  # Optional: Specify the output path for the mask results file
  phewas_output_path = "LDLR_phewas_results.rds",  # Optional: Specify the output path for the PheWAS results file,
  phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt",
  covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
  bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL",
  plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
  cores = 16
)
#' }
```
  
```{r tests-run_pmbb_phewas_report}
test_that("run_phewas_report works", {
  expect_true(inherits(run_pmbb_phewas_report, "function")) 
  skip()

})
```

## Render a report from pre-saved pheWAS output
    
```{r function-render_pmbb_phewas_report}
#' Render PheWAS Report
#' 
#' This function renders an HTML report from pre-saved genotype mask and PheWAS output files.
#' 
#' @param mask_output_path Path to the saved genotype output for each mask
#' @param phewas_output_path Path to the saved PheWAS output dataframe
#' @param output_file Full path to save the HTML report
#' @param template_path Optional path to a custom Quarto template file. If not provided, the default template will be used. This template should be a Quarto document with the necessary code to render the PheWAS report, and must be located in the top directory of the current project. An example template can be generated using: `usethis::use_template(".phecode_phewas_template.qmd", save_as = "phecode_phewas_template.qmd", package = "pmbbPheWASr")`, which will be saved in the current working directory.
#' @param ... Additional named parameters to pass to the Quarto document
#' 
#' @return The function renders an HTML report and returns silently
#' 
#' @export
render_pmbb_phewas_report <- function(mask_output_path, phewas_output_path, output_file, template_path = NULL, ...) {
  
  if(!is.null(template_path)) {
    if(!file.exists(template_path)) {
    cli::cli_abort("{.arg template_path} does not exist. Please provide a valid path to a Quarto template file.")
  }
  } else {
    template_path <- ".phecode_phewas_template.qmd"
    usethis::use_template(".phecode_phewas_template.qmd", package = "pmbbPheWASr")
  }
  
  quarto::quarto_render(
    input = template_path,
    output_format = "html",
    execute_params = list(
      mask_results = fs::path_abs(mask_output_path),
      phewas_results = fs::path_abs(phewas_output_path),
      ...
    ),
    output_file = output_file
  )
  
  fs::file_delete(".phecode_phewas_template.qmd")
  
  # Return the path to the generated report file
  cli::cli_alert_success("PheWAS report rendered successfully: {.val {output_file}}")
}
```
  
```{r example-render_pmbb_phewas_report, eval=FALSE}
#' \dontrun{
render_pmbb_phewas_report()
#' }
```
  
```{r tests-render_pmbb_phewas_report}
test_that("render_pmbb_phewas_report works", {
  expect_true(inherits(render_pmbb_phewas_report, "function"))

  skip()
  render_pmbb_phewas_report(
    phewas_output_path = "/project/damrauer_shared/Users/mglevin/pmbbPheWASr/tests/testthat/LDLR_phewas_results.rds",
    mask_output_path = "/project/damrauer_shared/Users/mglevin/pmbbPheWASr/tests/testthat/LDLR_mask_results.rds",
    output_file = "LDLR_report.html"
  )
})
```
  

```{r, eval=FALSE, include=FALSE}
run_phewas_report <- function(gene, annotation_file, gene_col, masks, mask_operator, variant_id_col, effect_allele_col, plink_bin, bfile, phecode_file, covariate_files, populations, covariate_population_col, covariate_cols, mask_output_path = NULL, phewas_output_path = NULL, ...) {
  
  # Get the function call as a string
  function_call <- deparse(match.call())
  
  # return(function_call)
  
  # Extract genotypes for a series of masks
  mask_res <- pmbb_extract_genotype_masks(
    gene = gene,
    annotation_file = annotation_file,
    gene_col = gene_col,
    masks = masks,
    mask_operator = mask_operator,
    variant_id_col = {{ variant_id_col }},
    effect_allele_col = {{ effect_allele_col }},
    plink_bin = plink_bin,
    bfile = bfile
  )
  
  # Save the mask results to a file
  if (is.null(mask_output_path)) {
    # Use a temporary file if mask_output_path is not provided
    mask_output_path <- tempfile(fileext = ".rds")
  }
  saveRDS(mask_res, file = mask_output_path)
  
  # Run a PheWAS
  phewas_res <- run_pmbb_phewas(
    mask_genotypes_list = mask_res,
    phecode_file = phecode_file,
    covariate_files = covariate_files,
    populations = populations,
    covariate_population_col = {{ covariate_population_col }},
    covariate_cols = {{ covariate_cols }},
    ...
  )
  
  # Save the PheWAS results to a file
  if (is.null(phewas_output_path)) {
    # Use a temporary file if phewas_output_path is not provided
    phewas_output_path <- tempfile(fileext = ".rds")
  }
  saveRDS(phewas_res, file = phewas_output_path)
  
  # Collapse the gene names into a single string
  gene_names <- glue::glue_collapse(gene, last = ", and ", sep = ", ")
  
  # Render the Quarto document using the saved files, function call, and gene names as execute_params
  
  usethis::use_template(".phecode_phewas_template.qmd", package = "pmbbPheWASr")
  
  quarto::quarto_render(
    input = ".phecode_phewas_template.qmd",
    output_format = "html",
    execute_params = list(
      mask_results = fs::path_abs(mask_output_path),
      phewas_results = fs::path_abs(phewas_output_path),
      function_call = function_call,
      gene_names = gene_names
    ),
    output_file = paste0(gene_names, "_phewas_report.html")
  )
  
  # Return the paths to the saved mask and PheWAS results files
  return(list(
    mask_output_path = mask_output_path,
    phewas_output_path = phewas_output_path
  ))
}
```


```{r, eval=FALSE, include=FALSE}
# Example usage
run_pmbb_phewas_report(
  gene = c("LDLR"),
  annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  gene_col = "Gene.refGene",
  masks = list(
    plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001")
  ),
  mask_operator = list(
    plof_0.001 = "burden"
  ),
  variant_id_col = ID,
  effect_allele_col = Alt,
  plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
  bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL",
  phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt",
  covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
  populations = c("ALL", "EUR", "AFR"),
  covariate_population_col = "Class",
  covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC")),
  mask_output_path = "LDLR_mask_results.rds",  # Optional: Specify the output path for the mask results file
  phewas_output_path = "LDLR_phewas_results.rds",  # Optional: Specify the output path for the PheWAS results file,
  cores = 16
)
```


```{r, eval=FALSE, include=FALSE}
job::job({run_pmbb_phewas_report(
    gene = c("ANGPTL3", "ANGPTL4", "ANGPTL8", "APOC3"),
    annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
    gene_col = "Gene.refGene",
    masks = list(
        plof_0.01 = list(ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", gnomAD_exome_ALL = "< 0.01"),
        missense_0.01 = list(ExonicFunc.ensGene = "%in% c('nonsynonymous SNV')", gnomAD_exome_ALL = "< 0.01")
    ),
    mask_operator = list(
        plof_0.01 = "burden",
        missense_0.01 = "burden"
    ),
    variant_id_col = ID,
    effect_allele_col = Alt,
    populations = c("ALL", "EUR", "AFR"),
    covariate_population_col = "Class",
    covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC")),
    mask_output_path = "TRL_mask_results.rds",  # Optional: Specify the output path for the mask results file
    phewas_output_path = "TRL_phewas_results.rds",  # Optional: Specify the output path for the PheWAS results file,
    phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt",
    covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL",
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    cores = 16
)}, title = "TRL PheWAS")
```


```{r, eval=FALSE, include=FALSE}
apoe_variants <- awk_str_filter(
  filename = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  filter_col = "Gene.refGene",
  filter_str = c("APOE"))

apoe4_mask_res <- pmbb_extract_genotype_masks(
  gene = "APOE",
  annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  gene_col = "Gene.refGene",
  masks = list(
    apoe4_burden = list(avsnp150 = "%in% c('rs429358', 'rs7412')"),
    apoe_single = list(avsnp150 = "%in% c('rs429358', 'rs7412')")
  ),
  mask_operator = list(
    apoe4_burden = "burden",
    apoe_single = "single"
  ),
  variant_id_col = ID,
  effect_allele_col = Alt,
  plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
  bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
)

job::job({run_pmbb_phewas_report(
    gene = c("APOE"),
    annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
    gene_col = "Gene.refGene",
    masks = list(
      # apoe4_burden = list(avsnp150 = "%in% c('rs429358', 'rs7412')"),
      apoe_single = list(avsnp150 = "%in% c('rs429358', 'rs7412')")
    ),
    mask_operator = list(
      # apoe4_burden = "burden",
      apoe_single = "single"
    ),
    variant_id_col = ID,
    effect_allele_col = Alt,
    populations = c("ALL", "EUR", "AFR"),
    covariate_population_col = "Class",
    covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC")),
    mask_output_path = "APOE_mask_results.rds",  # Optional: Specify the output path for the mask results file
    phewas_output_path = "APOE_phewas_results.rds",  # Optional: Specify the output path for the PheWAS results file,
    phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt",
    covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL",
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    cores = 16
)}, title = "APOE PheWAS")
```


```{r, eval=FALSE, include=FALSE}
  render_pmbb_phewas_report(
    phewas_output_path = "/project/damrauer_shared/Users/mglevin/pmbbPheWASr/APOE_phewas_results.rds",
    mask_output_path = "/project/damrauer_shared/Users/mglevin/pmbbPheWASr/APOE_mask_results.rds",
    output_file = "APOE_report.html"
  )

```


<!--
# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_pmbb_phewas.Rmd", vignette_name = "Get started")
```
