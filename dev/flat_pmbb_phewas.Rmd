---
title: "PMBB Phenome-wide Association Studies"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.

- There already is a dataset in the "inst/" directory to be used in the examples below
-->

```{r development-dataset, eval=FALSE}
# Run all this chunk in the console directly
# There already is a dataset in the "inst/" directory
# Make the dataset file available to the current Rmd during development
pkgload::load_all(path = here::here(), export_all = FALSE)
#
# # You will be able to read your example data file in each of your function examples and tests as follows - see chunks below
# datafile <- system.file("nyc_squirrels_sample.csv", package = "pmbbPheWASr")
# nyc_squirrels <- read.csv(datafile, encoding = "UTF-8")
#
# nyc_squirrels
```


# Filter Variant Annotations File

The `awk_str_filter` function can be used to filter arbitrary rows from a tab-delimited text file using `awk`. The function accepts the path to a tab-delimited text file, name of a column to filter, and the string to filter for. The function returns a tibble containing the filtered rows. This function can be used to filter the PMBB variant annotations file to only include variants within the specified gene(s).
    
```{r function-awk_str_filter}
#' Filter arbitrary rows from a tab-delimited text file using awk
#'
#' This function wraps the system command `awk` to efficiently filter rows from a tab-delimited text file. The function accepts the path to a tab-delimited text file, name of a column to filter, and the string to filter for. The function returns a tibble containing the filtered rows.
#'
#' @param filename The path to the tab-delimited text file.
#' @param filter_col The name of the column to filter.
#' @param filter_str A character vector of strings to filter for in the specified column.
#'
#' @return
#'
#' A [tibble::tibble()] containing the filtered rows from the input file
#'
#' @export
#'
awk_str_filter <- function(filename, filter_col, filter_str) {
  # Check if the file exists
  if (!file.exists(filename)) {
    cli::cli_abort("File does not exist: {filename}")
  }

  cli::cli_progress_step("Extracting '{filter_str}' from column '{filter_col}' in {.val {filename}}")

  # Determine the column index based on the filter_col
  header <- readLines(filename, n = 1)
  col_names <- strsplit(header, "\t")[[1]]
  col_index <- which(col_names == filter_col)

  if (length(col_index) == 0) {
    cli::cli_abort("Column not found: {filter_col}")
  }

  # Construct the awk command
  # awk_cmd <- paste0("awk -F'\t' '", paste0("$", col_index, " ~ /", paste(filter_str, collapse = "|"), "/"), "' ", shQuote(filename))

  awk_cmd <- c(paste0("NR == 1 || ", paste0("($", col_index, " == \"", filter_str, "\")", collapse = " || ")), filename)

  # Execute the awk command using processx
  result <- processx::run(
    command = "awk",
    args = awk_cmd,
    error_on_status = TRUE
  )

  # Check if the command executed successfully
  if (result$status != 0) {
    cli::cli_abort("Error executing awk command: {result$stderr}")
  }

  # Format the filtered output using data.table::fread()
  filtered_dt <- data.table::fread(
    text = result$stdout,
    sep = "\t",
    header = TRUE,
    stringsAsFactors = FALSE,
    quote = "",
    na.strings = "."
  )

  # Convert the data.table to a tibble
  filtered_tibble <- tibble::as_tibble(filtered_dt)

  return(filtered_tibble)
}
```
  
```{r example-awk_str_filter, eval=FALSE}
#' \dontrun{
cftr_variants <- awk_str_filter(
  filename = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  filter_col = "Gene.refGene",
  filter_str = c("CFTR")
)
#' }
```
  
```{r tests-awk_str_filter}
test_that("awk_str_filter works", {
  ldlr_file <- "ldlr_df.tsv"
  if (!file.exists(ldlr_file)) {
    # The path to use during dev in the flat file
    ldlr_file <- file.path("tests", "testthat", ldlr_file)
    if (!file.exists(ldlr_file)) {
      stop(ldlr_file, " does not exist")
    }
  }

  res <- awk_str_filter(
    filename = ldlr_file,
    filter_col = "Gene.refGene",
    filter_str = c("LDLR")
  )
  expect_true(inherits(awk_str_filter, "function"))
  expect_true(tibble::is_tibble(res))
})
```

# Apply variant masks to annotation file
    
The `apply_variant_masks` function applies variant mask criteria to a data frame containing variant annotations. The function can accept multiple sets of filter criteria, each defined as a list of column names and filter conditions. The resulting filtered data frames are returned as a named list.

```{r function-apply_variant_masks}
#' Apply variant masks to annotation file
#'
#' This function applies variant mask criteria to a data frame containing variant annotations. The function can accept multiple sets of filter criteria, each defined as a list of column names and filter conditions. The resulting filtered data frames are returned as a named list.
#'
#' @param annotation_df A data frame to be filtered.
#' @param masks A named list of lists containing filter criteria.
#'   Each element of the outer list should be named after the desired output name for the filtered data frame (eg. name of the variant mask).
#'   Each inner list should contain the filter criteria for a specific set of columns.
#'   For example: list(plof_0.001 = list(ExonicFunc.ensGene = "= stopgain", gnomAD_exome_ALL = "< 0.001"), common_0.01 = list(gnomAD_exome_ALL = "> 0.01"))
#'
#' @return A named list of filtered [tibble::tibble()]s based on the provided filter criteria.
#'
#' @export

apply_variant_masks <- function(annotation_df, masks) {
  # Check if the input is a data frame
  if (!is.data.frame(annotation_df)) {
    rlang::abort("Input must be a data frame.")
  }

  # Check if the masks is a list
  if (!is.list(masks)) {
    rlang::abort("Masks must be provided as a list.")
  }

  # Apply the filter criteria to the data frame for each mask
  filtered_dfs <- purrr::map(masks, function(mask) {
    list(
      variants = filter_dataframe(annotation_df, mask),
      mask = deparse(mask)
    )
  })

  # Set the names of the filtered data frames based on the names of the masks
  names(filtered_dfs) <- names(masks)

  return(filtered_dfs)
}
```
  
```{r example-apply_variant_masks, eval=FALSE}
#' \dontrun{

# Extract variants in a gene
cftr_variants <- awk_str_filter(
  filename = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  filter_col = "Gene.refGene",
  filter_str = c("CFTR")
)

# Apply the specified masks to the set of variants
apply_variant_masks(
  cftr_variants,
  masks = list(
    plof_lt_0.001 = list(ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", gnomAD_exome_ALL = "< 0.001"),
    p_lp_het_gt_10 = list(CLNSIG = "%in% c('Pathogenic', 'Pathogenic/Likely_pathogenic')", HET_REF_ALT_CTS = "> 10")
  )
)
#' }
```
  
```{r tests-apply_variant_masks}
test_that("apply_variant_masks works", {
  expect_true(inherits(apply_variant_masks, "function"))
})
```

```{r function-filter_dataframe}
#' Filter a Data Frame Based on Multiple Criteria
#'
#' This function filters a data frame based on a list of column names and corresponding filter criteria.
#' The filter criteria are provided as a list, where each element represents a column and its associated filter condition.
#' The function applies the filter criteria to the specified columns and returns the filtered data frame.
#'
#' @param df A data frame to be filtered.
#' @param filter_list A list containing column names and their corresponding filter criteria.
#'   Each element of the list should be named after the column to be filtered and contain the filter condition as a string.
#'   For example: list(age = "> 30", city = "== 'New York'")
#'
#' @return The filtered [tibble::tibble()] based on the provided filter criteria.
#'
#' @noRd

filter_dataframe <- function(df, filter_list) {
  # Check if the input is a data frame
  if (!is.data.frame(df)) {
    abort("Input must be a data frame.")
  }

  # Check if the filter list is a list
  if (!is.list(filter_list)) {
    abort("Filter criteria must be provided as a list.")
  }

  # Iterate over each element in the filter list
  for (col_filter in names(filter_list)) {
    # Extract the filter criteria
    filter_criteria <- filter_list[[col_filter]]

    # Check if the column exists in the data frame
    if (!(col_filter %in% colnames(df))) {
      cli::cli_abort("Column {.val {col_filter}} not found in the data frame. Skipping filter for this column.")
      next
    }

    # Apply the filter criteria to the specified column using {{}}
    df <- df %>%
      dplyr::filter(!!rlang::parse_expr(paste0({{ col_filter }}, filter_criteria)))
  }

  return(df)
}
```
  
```{r example-filter_dataframe, eval=FALSE, include=FALSE}
#' \dontrun{
filter_dataframe(
  cftr_variants,
  filter_list = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001")
)
#' }
```
  
```{r tests-filter_dataframe}
test_that("filter_dataframe works", {
  res <- filter_dataframe(dplyr::starwars, list(height = " > 100", eye_color = " == 'blue'"))
  expect_true(inherits(filter_dataframe, "function"))
  expect_true(tibble::is_tibble(res))
  expect_true(nrow(res) > 0)
})

test_that("filter_dataframe errors on missing columns", {
  expect_error(filter_dataframe(dplyr::starwars, list(missing_column_name = " > 100", eye_color = " == 'blue'")))
})
```


# Extracting genotypes

## Extract a single set of variants

The `pmbb_extract_genotypes` function is a wrapper around `plink2` to extract genotypes from PMBB plink files. The function accepts the path to the plink files and the list of variant IDs to extract. The function returns a long-format tibble containing the extracted genotypes for each PMBB participant.

```{r function-pmbb_extract_genotypes}
#' Extract genotypes from PMBB plink files
#'
#' This function is a wrapper around `plink2` to extract genotypes from PMBB plink files. The function accepts the path to the plink files and the list of variant IDs to extract. The function returns a long-format [tibble::tibble()] containing the extracted genotypes for each PMBB participant.
#'
#' @param variant_df A data frame containing the variant information.
#' @param variant_id_col The name of the column in `variant_df` that contains the variant IDs.
#' @param effect_allele_col The name of the column in `variant_df` that contains the effect alleles.
#' @param plink_bin The path to the `plink2` binary executable.
#' @param bfile The prefix of the plink binary files (without the file extension).
#' @param threads The number of threads to use for parallel processing (default: 1).
#' @param memory The amount of memory (in MB) to allocate for `plink2` (default: 8000).
#'
#' @return A long-format [tibble::tibble()] containing the extracted genotypes for each PMBB participant.
#'
#' @family {genotypes}
#' @export

pmbb_extract_genotypes <- function(variant_df, variant_id_col, effect_allele_col, plink_bin, bfile, threads = 1, memory = 8000) {
  cli::cli_progress_step("Extracting genotypes from {.val {bfile}}")

  allele_file <- fs::file_temp()
  genotype_file <- fs::path(fs::path_temp(), "genotypes")

  allele_table <- variant_df %>%
    dplyr::select(!!rlang::ensym(variant_id_col), !!rlang::ensym(effect_allele_col))

  allele_table %>%
    data.table::fwrite(allele_file, col.names = FALSE, sep = "\t")

  plink_result <- processx::run(
    command = plink_bin,
    args = c(
      "--bfile", bfile,
      "--threads", threads,
      "--memory", memory,
      "--snps", variant_df %>% dplyr::pull(!!rlang::ensym(variant_id_col)),
      "--export-allele", allele_file,
      "--export", "A",
      "--out", genotype_file
    ),
    error_on_status = TRUE
  )

  if (plink_result$status != 0) {
    cli::cli_abort("Error executing plink command. Status: {plink_result$stderr}")
  }

  genotype_raw_file <- paste0(genotype_file, ".raw")

  if (!file.exists(genotype_raw_file)) {
    cli::cli_abort("Genotype file not found: {genotype_raw_file}")
  }

  genotype_df <- data.table::fread(genotype_raw_file)

  genotype_tbl <- genotype_df %>%
    tibble::as_tibble() %>%
    tidytable::pivot_longer(
      cols = -c(`FID`, `IID`, `PAT`, `MAT`, `SEX`, `PHENOTYPE`),
      names_to = "variant_id",
      values_to = "genotype"
    ) %>%
    dplyr::select(PMBB_ID = IID, variant_id, genotype) %>%
    dplyr::as_tibble()

  return(genotype_tbl)
}
```
  
```{r example-pmbb_extract_genotypes, eval=FALSE}
#' \dontrun{
pmbb_extract_genotypes(
  variant_df = cftr_variants,
  variant_id_col = ID,
  effect_allele_col = Alt,
  plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
  bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
)
#' }
```
  
```{r tests-pmbb_extract_genotypes}
test_that("pmbb_extract_genotypes works", {
  expect_true(inherits(pmbb_extract_genotypes, "function"))

  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())

  ldlr_file <- "ldlr_df.tsv"
  if (!file.exists(ldlr_file)) {
    # The path to use during dev in the flat file
    ldlr_file <- file.path("tests", "testthat", ldlr_file)
    if (!file.exists(ldlr_file)) {
      stop(ldlr_file, " does not exist")
    }
  }

  ldlr_variants <- data.table::fread(ldlr_file)

  ldlr_genotype_res <- pmbb_extract_genotypes(
    variant_df = ldlr_variants,
    variant_id_col = ID,
    effect_allele_col = Alt,
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
  )
  expect_true(tibble::is_tibble(ldlr_genotype_res))
})
```

## Extract genotypes based on masks 

The `pmbb_extract_genotype_masks` function extracts genotypes for a subset of participants based on a set of masks. This function wraps `awk_str_filter`, `apply_variant_masks`, and `pmbb_extract_genotypes` to extract genotypes for PMBB participants based on a set of masks. 
    

```{r function-pmbb_extract_genotype_masks}
#' Extract genotypes based on variant masks
#'
#' This function extracts genotypes for a subset of participants based on a set of masks. It wraps `awk_str_filter`, `apply_variant_masks`, and `pmbb_extract_genotypes` to extract genotypes for PMBB participants based on a set of masks.
#'
#' @param annotation_file The path to the variant annotation file.
#' @param gene The name of the gene to filter variants for.
#' @param gene_col The name of the column in the annotation file to filter the gene on.
#' @param masks A named list of lists containing filter criteria for each mask.
#'   Each element of the outer list should be named after the desired output name for the filtered data frame (eg. name of the variant mask).
#'   Each inner list should contain the filter criteria for a specific set of columns.
#'   For example: list(plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"), common_0.01 = list(gnomAD_exome_ALL = "> 0.01"))
#' @param variant_id_col The name of the column in the annotation file that contains the variant IDs.
#' @param effect_allele_col The name of the column in the annotation file that contains the effect alleles.
#' @param mask_operator A named list specifying the operation to perform for each mask. Valid operations are "burden" (default) and "single".
#'   The names in the mask_operator list should correspond to the names in the masks list.
#'   For example: list(plof_0.001 = "burden", common_0.01 = "single")
#' @param plink_bin The path to the `plink2` binary executable.
#' @param bfile The prefix of the plink binary files (without the file extension).
#' @param threads The number of threads to use for parallel processing (default: 1).
#' @param memory The amount of memory (in MB) to allocate for `plink2` (default: 8000).
#'
#' @return A named list, where each element represents a mask and contains a list with components based on the specified mask_operator:
#'          - "variants": A [tibble::tibble()] of the variants included in the mask.
#'          - "genotypes": A [tibble::tibble()] containing the genotype for each PMBB participant.
#'          - "mask": A string containing the mask applied to filter the variants.
#'          - "mask_type": A [tibble::tibble()] containing the mask type applied (eg. "burden" or "single").
#'
#' @family {genotypes}
#' @export

pmbb_extract_genotype_masks <- function(gene, annotation_file, gene_col, masks, variant_id_col, effect_allele_col, mask_operator = NULL, plink_bin, bfile, threads = 1, memory = 8000) {
  # Check if the names in the mask_operator list are present in the masks list
  if (!is.null(mask_operator) && !all(names(mask_operator) %in% names(masks))) {
    missing_masks <- setdiff(names(mask_operator), names(masks))
    cli::cli_abort("The following mask operators are not present in the masks list: {missing_masks}")
  }

  cli::cli_progress_step("Filtering variants for gene: {.val {gene}}")

  gene_variants <- awk_str_filter(
    filename = annotation_file,
    filter_col = gene_col,
    filter_str = gene
  )

  cli::cli_progress_step("Applying variant masks")

  masked_variants <- apply_variant_masks(gene_variants, masks)

  cli::cli_progress_step("Extracting unique set of variant IDs across all masks")

  unique_variant_ids <- masked_variants %>%
    purrr::map(\(x) purrr::pluck(x, "variants") %>% dplyr::pull(!!rlang::ensym(variant_id_col))) %>%
    purrr::reduce(union)

  if (length(unique_variant_ids) == 0) {
    cli::cli_abort("No unique variants identified across all masks")
  }

  cli::cli_progress_step("Extracting genotypes for unique set of variant IDs")

  genotype_df <- pmbb_extract_genotypes(
    variant_df = gene_variants %>% dplyr::filter(!!rlang::ensym(variant_id_col) %in% unique_variant_ids),
    variant_id_col = !!rlang::ensym(variant_id_col),
    effect_allele_col = !!rlang::ensym(effect_allele_col),
    plink_bin = plink_bin,
    bfile = bfile,
    threads = threads,
    memory = memory
  )

  cli::cli_progress_step("Processing genotypes for each variant mask")

  mask_list <- purrr::imap(masked_variants, function(variant_list, mask_name) {
    mask_genotypes <- genotype_df %>%
      dplyr::mutate(ID = stringr::str_replace(variant_id, "_[^_]+$", "")) %>%
      dplyr::filter(ID %in% (variant_list %>% purrr::pluck("variants") %>% dplyr::pull(!!rlang::ensym(variant_id_col))))

    if (is.null(mask_operator) || mask_operator[[mask_name]] == "burden") {
      mask_genotypes_summarized <- mask_genotypes %>%
        dplyr::group_by(PMBB_ID) %>%
        dplyr::summarize(genotype = sum(genotype, na.rm = TRUE), .groups = "drop") %>%
        dplyr::select(dplyr::everything(), genotype)

      list(
        variants = variant_list %>% purrr::pluck("variants") %>% dplyr::filter(!!rlang::ensym(variant_id_col) %in% mask_genotypes$ID),
        genotypes = mask_genotypes_summarized,
        mask = variant_list %>% purrr::pluck("mask"),
        mask_type = "burden"
      )
    } else if (mask_operator[[mask_name]] == "single") {
      mask_variants <- variant_list %>% purrr::pluck("variants")

      if (nrow(mask_variants) == 0) {
        list(list(
          name = mask_name,
          variants = tibble::tibble(),
          genotypes = tibble::tibble(PMBB_ID = character(), genotype = numeric()),
          mask = variant_list %>% purrr::pluck("mask"),
          mask_type = "single"
        ))
      } else {
        purrr::map(unique(mask_genotypes$variant_id), function(variant) {
          variant_genotypes <- mask_genotypes %>%
            dplyr::filter(variant_id == variant) %>%
            dplyr::select(dplyr::everything(), genotype)

          list(
            name = paste(mask_name, variant, sep = "_"),
            variants = variant_list %>% purrr::pluck("variants") %>% dplyr::filter(!!rlang::ensym(variant_id_col) == stringr::str_replace(variant, "_[^_]+$", "")),
            genotypes = variant_genotypes,
            mask = variant_list %>% purrr::pluck("mask"),
            mask_type = "single"
          )
        })
      }
    }
  })

  # Set the names of the mask_list for burden masks
  burden_mask_names <- names(mask_operator)[mask_operator == "burden"]
  names(mask_list)[names(mask_list) %in% burden_mask_names] <- burden_mask_names

  # Flatten the single-variant masks and set their names
  single_mask_list <- purrr::flatten(mask_list[names(mask_list) %in% names(mask_operator)[mask_operator == "single"]])
  # print(single_mask_list)
  names(single_mask_list) <- purrr::map_chr(single_mask_list, "name")
  single_mask_list <- purrr::map(single_mask_list, ~ purrr::keep(.x, names(.x) %in% c("variants", "genotypes", "mask", "mask_type")))

  # Combine the burden and single-variant masks into the final mask_list
  final_mask_list <- c(mask_list[names(mask_list) %in% burden_mask_names], single_mask_list)

  return(final_mask_list)
}
```


  
```{r example-pmbb_extract_genotype_masks, eval=FALSE}
#' \dontrun{
cftr_mask_res <- pmbb_extract_genotype_masks(
  gene = "CFTR",
  annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  gene_col = "Gene.refGene",
  masks = list(
    plof_lt_0.001 = list(ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", gnomAD_exome_ALL = "< 0.001"),
    p_lp_het_gt_10 = list(CLNSIG = "%in% c('Pathogenic', 'Pathogenic/Likely_pathogenic')", HET_REF_ALT_CTS = "> 10")
  ),
  mask_operator = list(
    plof_lt_0.001 = "burden",
    p_lp_het_gt_10 = "single"
  ),
  variant_id_col = ID,
  effect_allele_col = Alt,
  plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
  bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
)
#' }
```
  
```{r tests-pmbb_extract_genotype_masks}
test_that("pmbb_extract_genotype_masks works", {
  expect_true(inherits(pmbb_extract_genotype_masks, "function"))

  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())

  cftr_mask_res <- pmbb_extract_genotype_masks(
    gene = "CFTR",
    annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
    gene_col = "Gene.refGene",
    masks = list(
      plof_lt_0.001 = list(ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", gnomAD_exome_ALL = "< 0.001"),
      p_lp_het_gt_10 = list(CLNSIG = "%in% c('Pathogenic', 'Pathogenic/Likely_pathogenic')", HET_REF_ALT_CTS = "> 10")
    ),
    mask_operator = list(
      plof_lt_0.001 = "burden",
      p_lp_het_gt_10 = "single"
    ),
    variant_id_col = ID,
    effect_allele_col = Alt,
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
  )

  expect_type(cftr_mask_res, "list")

  expect_error(
    pmbb_extract_genotype_masks(
      gene = "PNPLA2",
      annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
      gene_col = "Gene.refGene",
      masks = list(
        PNPLA2_plof_het_gt_10 = list(Gene.refGene = "== 'PNPLA2'", ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", HET_REF_ALT_CTS = "> 10")
      ),
      mask_operator = list(
        PNPLA2_plof_het_gt_10 = "single"
      ),
      variant_id_col = ID,
      effect_allele_col = Alt,
      plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
      bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
    )
  )

  pnpla2_mask_res <- pmbb_extract_genotype_masks(
    gene = "PNPLA2",
    annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
    gene_col = "Gene.refGene",
    masks = list(
      PNPLA2_plof_het_gt_10 = list(Gene.refGene = "== 'PNPLA2'", ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", HET_REF_ALT_CTS = "> 10"),
      PNPLA2_intronic = list(Gene.refGene = "== 'PNPLA2'", Func.ensGene = "== 'intronic'")
    ),
    mask_operator = list(
      PNPLA2_plof_het_gt_10 = "single",
      PNPLA2_intronic = "burden"
    ),
    variant_id_col = ID,
    effect_allele_col = Alt,
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
  )

  expect_type(pnpla2_mask_res, "list")
})
```

# PheWAS convenience functions

## Format PMBB phecode data

The `pmbb_format_phecodes` function takes a path to a PMBB phecode file and applies a case threshold to categorize individuals as cases or controls. The function returns a tibble with `PMBB_ID` and phecodes as columns, with TRUE/FALSE values for each phecode column.
    
```{r function-pmbb_format_phecodes}
#' Format PMBB phecode data
#'
#' Given a dataframe containing PMBB phecodes, apply a case treshold for categorizing individuals as cases or controls
#'
#' @param phecode_file Path to PMBB phecode file used to run PheWAS
#' @param phecode_case_threshold Number of cases required to classify an individual as a case
#'
#' @return A [tibble::tibble()] containing `PMBB_ID` and phecodes as columns, with TRUE/FALSE values for each phecode column

#' @family {phenotypes}
#' @export

pmbb_format_phecodes <- function(phecode_file, phecode_case_threshold = 2) {
  cli::cli_progress_step("Formatting {phecode_file}")

  vroom::vroom(phecode_file, show_col_types = FALSE) %>%
    tidytable::pivot_longer(cols = c(-PMBB_ID)) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(case = dplyr::if_else(value >= phecode_case_threshold, TRUE, FALSE)) %>%
    tidytable::select(PMBB_ID, name, case) %>%
    tidytable::pivot_wider(names_from = name, values_from = case, values_fill = FALSE) %>%
    tibble::as_tibble() %>%
    # unique() %>%
    assertr::assert(assertr::is_uniq, PMBB_ID)
}
```
  
```{r example-pmbb_format_phecodes, eval=FALSE}
#' \dontrun{
pmbb_phecodes_df <- pmbb_format_phecodes(phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt", phecode_case_threshold = 2)
#' }
```
  
```{r tests-pmbb_format_phecodes}
test_that("pmbb_format_phecodes works", {
  expect_true(inherits(pmbb_format_phecodes, "function"))
  phenotypes <- "phecodes.tsv"
  if (!file.exists(phenotypes)) {
    # The path to use during dev in the flat file
    phenotypes <- file.path("tests", "testthat", phenotypes)
    if (!file.exists(phenotypes)) {
      stop(phenotypes, " does not exist")
    }
  }

  res <- pmbb_format_phecodes(phenotypes)
  expect_true(tibble::is_tibble(res))
})
```
  

    
```{r function-pmbb_format_covariates}
#' Format covariate data for PheWAS
#'
#' This function reads and processes covariate files for use in PheWAS analysis.It checks if the specified covariate files exist, reads them, and performs the necessary data formatting and validation. If multiple files are specified they will be joined together from left-to-right, keeping duplicated columns from the left-most file.
#'
#' @param covariate_files Path to PMBB covariate file(s) used to run PheWAS. If multiple files are provided, they will be joined by `PMBB_ID`, and values for duplicated columns will be preserved from the from the file that is specified earlier.
#' @param covariate_cols Vector of columns in the covariate file that should be used as covariates in the PheWAS
#' @param covariate_population_col Column containing population labels in the covariate file, required if `populations` is not `"ALL"`
#' @param populations A character vector of populations to run PheWAS on. Default is `c("ALL")`

#' @family {phenotypes}
#' @return A formatted covariate dataframe with selected columns and unique PMBB_IDs.
#'

pmbb_format_covariates <- function(covariate_files, covariate_cols, covariate_population_col, populations) {
  # Check if covariates exists - this may include multiple files
  covariates_exists <- purrr::map(covariate_files, file.exists) %>%
    unlist()

  if (FALSE %in% purrr::map(covariate_files, file.exists)) {
    missing_covariates_files <- covariate_files[!covariates_exists]
    cli::cli_abort("{missing_covariates_files} does not exist")
  }

  # Check if populations is a character vector
  if (!is.character(populations)) {
    cli::cli_abort("{.arg populations} must be a character vector")
  }

  # Check if populations contains values other than "ALL"
  populations <- unique(populations)
  if (length(sum(stringr::str_detect(populations, "ALL"))) / length(populations) != 1) {
    if (rlang::quo_is_null(rlang::enquo(covariate_population_col))) {
      cli::cli_abort("{.arg covariate_population_col} must be provided if {.arg populations} contains values other than {.val ALL}")
    }
  }

  cli::cli_progress_step("Reading covariate file(s): {covariate_files}")

  covariate_df <- purrr::map(covariate_files, \(x) vroom::vroom(x, show_col_types = FALSE) %>% unique()) %>%
    purrr::reduce(dplyr::left_join, by = c("PMBB_ID"), suffix = c("", "_duplicated")) %>%
    dplyr::select(-tidyselect::ends_with("_duplicated")) %>%
    unique()

  if (!rlang::quo_is_null(rlang::enquo(covariate_population_col))) {
    # TODO need better checking that the covariate_population_col is in the covariate_df

    covariate_populations <- unique(covariate_df %>% dplyr::pull({{ covariate_population_col }}))
    missing_populations <- setdiff(populations, covariate_populations)
    missing_populations <- purrr::discard(missing_populations, function(x) x == "ALL")

    if (length(missing_populations > 0)) {
      cli::cli_abort("Population(s) {.val {missing_populations}} not found in covariate file")
    }

    cli::cli_alert_info("All populations were found in the covariates file")
  }

  covariate_df %>%
    dplyr::select(PMBB_ID, {{ covariate_cols }}, !!rlang::ensym(covariate_population_col)) %>%
    assertr::assert(assertr::is_uniq, PMBB_ID)
}
```
  
```{r example-pmbb_format_covariates, eval=FALSE, include=FALSE}
#' \dontrun{
pmbb_covariates_df <- pmbbPheWASr:::pmbb_format_covariates(
  covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
  populations = c("ALL", "EUR"),
  covariate_population_col = Class,
  covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, starts_with("Genotype_PC"))
)
#' }
```
  
```{r tests-pmbb_format_covariates}
test_that("pmbb_format_covariates works", {
  expect_true(inherits(pmbb_format_covariates, "function"))

  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())

  pmbb_covariates_res <- pmbb_format_covariates(
    covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
    populations = c("ALL", "EUR"),
    covariate_population_col = Class,
    covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC"))
  )

  expect_true(inherits(pmbb_covariates_res, "data.frame"))
})
```
  
    
```{r function-pmbb_format_labs}
#' Format labs data for PheWAS
#'
#' This function will read in labs data from PMBB and format it for use in a PheWAS. By default, this function will return a data frame with summary measures (`min`, `median`, `mean`, `max`) of each lab value for each individual in the PMBB cohort. Because PMBB lab data is only roughly cleaned, the function will by default select only the most common `RESULT_NAME` for each lab test.

#'
#'
#' @param labs_files A character vector of file paths to the labs data
#' @param patient_class A character vector of patient classes (location of lab testing) to include in the analysis. Default is `"Outpatient"`
#'
#' @return A [tibble::tibble()] containing `PMBB_ID` and summary measures of lab values for each PMBB participant
#' @import duckdb dbplyr
#'
#' @family {phenotypes}
#' @export

pmbb_format_labs <- function(labs_files, patient_class = "Outpatient") {
  rlang::arg_match(patient_class, c("Inpatient", "Outpatient"))

  cli::cli_progress_step("Processing labs data: {.val {labs_files}}")

  # TODO add fuzzy matching for lab names
  # if(fuzzy) {
  # lab_counts_df <- arrow::open_tsv_dataset(labs_files) %>%
  #   dplyr::select(PMBB_ID, PATIENT_CLASS, RESULT_NAME, RESULT_VALUE_NUM) %>%
  #   dplyr::filter(PATIENT_CLASS %in% patient_class) %>%
  #   dplyr::mutate(file = add_filename()) %>%
  #   # head(1000) %>%
  #   dplyr::compute() %>%
  #   arrow::to_duckdb() %>%
  #   dplyr::group_by(file, RESULT_NAME) %>%
  #   dplyr::summarize(n = n(), .groups = "drop") %>%
  #   dplyr::group_by(file) %>%
  #   dplyr::arrange(desc(n), .by_group = TRUE) %>%
  #   dplyr::ungroup() %>%
  #   dplyr::filter(n > min_records) %>%
  #   dplyr::collect()
  #
  # lab_counts_df <- lab_counts_df %>%
  #   dplyr::group_by(file) %>%
  #   dplyr::slice_max(n) %>%
  #   dplyr::ungroup() %>%
  #   dplyr::mutate(lead_result_name = stringr::str_to_lower(RESULT_NAME)) %>%
  #   dplyr::select(lead_result_name) %>%
  #   fuzzyjoin::stringdist_left_join(lab_counts_df %>% dplyr::mutate(result = stringr::str_to_lower(RESULT_NAME)), by = c("lead_result_name" = "result"), method = "jw", max_dist = 0.4)
  #
  # return(lab_counts_df)
  #
  # }

  arrow::open_tsv_dataset(labs_files) %>%
    dplyr::select(PMBB_ID, PATIENT_CLASS, RESULT_NAME, RESULT_VALUE_NUM) %>%
    dplyr::filter(PATIENT_CLASS %in% patient_class) %>%
    dplyr::mutate(file = add_filename()) %>%
    # head(1000) %>%
    dplyr::compute() %>%
    arrow::to_duckdb() %>%
    dplyr::add_count(RESULT_NAME) %>%
    dplyr::group_by(file) %>%
    dplyr::slice_max(n) %>%
    dplyr::collect() %>%
    dplyr::group_by(PMBB_ID, RESULT_NAME) %>%
    dplyr::summarise(across(RESULT_VALUE_NUM, list(min = min, median = median, mean = mean, max = max), .names = "{.fn}"), .groups = "drop") %>%
    # dplyr::ungroup() %>%
    tidytable::pivot_wider(
      id_cols = PMBB_ID,
      names_from = RESULT_NAME,
      values_from = c(min, median, mean, max),
      names_glue = "{RESULT_NAME}_{.value}"
    ) %>%
    dplyr::ungroup() %>%
    dplyr::rename_with(janitor::make_clean_names, .cols = -PMBB_ID) %>%
    tibble::as_tibble()
}
```
  
```{r example-pmbb_format_labs, eval=FALSE, include=FALSE}
#' \dontrun{
pmbb_labs_df <- fs::dir_ls("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/", glob = "*labs*", recurse = TRUE) %>%
  pmbb_format_labs()
#' }
```
  
```{r tests-pmbb_format_labs}
test_that("pmbb_format_labs works", {
  expect_true(inherits(pmbb_format_labs, "function"))

  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())
  pmbb_labs_df <- fs::dir_ls("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/", glob = "*labs*", recurse = TRUE) %>%
    head(1) %>%
    pmbb_format_labs()

  expect_true(nrow(pmbb_labs_df) > 0)
})
```
  
## Run a PheWAS

The `run_pmbb_phewas` function runs a PheWAS on the PMBB data, using the results of the `pmbb_extract_genotype_masks` function and paths to PMBB files containing phenotype and covariate data. 
    
```{r function-run_pmbb_phewas}
#' Run a PheWAS on PMBB data
#'
#' This function runs a PheWAS on PMBB data, using genotype information and paths to PMBB files containing phenotype and covariate data. The function ideally accepts genotype information from the `pmbb_extract_genotype_masks` function, but can accept any genotype information of the format `list(mask_name = list(genotypes = data.frame(PMBB_ID = character(), genotype = character())))`
#'
#' @param mask_genotypes_list A named list, where each element contains a named element called `genotypes` which contains `PMBB_ID` and `genotype` columns.
#' @param phenotypes Path to PMBB phenotype file or a dataframe containing phenotype data used to run PheWAS
#' @param covariates Path to PMBB covariate file(s) or a dataframe containing covariate data used to run PheWAS. If multiple files are provided, they will be joined by `PMBB_ID`, and values for duplicated columns will be preserved from the from the file that is specified earlier.
#' @param populations A character vector of populations to run PheWAS on. Default is `c("ALL")`
#' @param covariate_cols Vector of columns in the covariate file or dataframe that should be used as covariates in the PheWAS
#' @param covariate_population_col Column containing population labels in the covariate file or dataframe, required if `populations` is not `ALL`
#' @param phenotype_case_count The minimum number of codes required to be considered a case (Default: 2)
#' @param ... Additional arguments passed to [PheWAS::phewas()]

#' @return A [tibble::tibble()] containing the results of the PheWAS for each population and mask
#'
#' @family {phewas}
#' @export
run_pmbb_phewas <- function(mask_genotypes_list, phenotypes, covariates, populations = c("ALL"), covariate_cols, covariate_population_col = NULL, phenotype_case_count = 2, ...) {
  # Check if mask_genotypes_list is a list
  if (!is.list(mask_genotypes_list)) {
    cli::cli_abort("{.arg mask_genotypes_list} must be a list")
  }

  # Check if phenotype_file is a file path or a dataframe
  if (is.character(phenotypes)) {
    if (!file.exists(phenotypes)) {
      cli::cli_abort("{phenotype_file} does not exist")
    }
    phecode_df <- pmbb_format_phecodes(phecode_file = phenotypes, phecode_case_threshold = phenotype_case_count)
  } else if (is.data.frame(phenotypes)) {
    phecode_df <- phenotypes
  } else {
    cli::cli_abort("{.arg phenotypes} must be a file path or a dataframe")
  }

  # Format covariate data
  if (is.character(covariates)) {
    covariate_df <- pmbb_format_covariates(covariates, {{ covariate_cols }}, !!rlang::ensym(covariate_population_col), populations)
  } else if (is.data.frame(covariates)) {
    covariate_df <- covariates
  } else {
    cli::cli_abort("{.arg covariates} must be file paths or a dataframe")
  }

  # Run PheWAS
  cli::cli_progress_step("Running PheWAS")

  phewas_combos <- tidyr::expand_grid(genotype_masks = mask_genotypes_list, population = populations) %>%
    dplyr::mutate(mask_name = purrr::imap(genotype_masks, ~.y)) %>%
    tidyr::unnest(mask_name)

  phewas_res_list <- purrr::pmap(phewas_combos, \(genotype_masks, population, mask_name) {
    if (population != "ALL") {
      covariate_df <- covariate_df %>%
        dplyr::filter(!!rlang::ensym(covariate_population_col) == population) %>%
        dplyr::select(-!!rlang::ensym(covariate_population_col))
    } else {
      covariate_df <- covariate_df %>%
        dplyr::select(-!!rlang::ensym(covariate_population_col))
    }

    allele_counts <- genotype_masks %>%
      purrr::pluck("genotypes") %>%
      dplyr::count(genotype)

    additive <- dplyr::if_else(genotype_masks %>% purrr::pluck("mask_type") == "single", TRUE, FALSE)
    
    # Run PheWAS, but return NA if there is an error - this will allow PheWAS for other masks/populations to run
    phewas_possibly <- purrr::possibly(PheWAS::phewas, otherwise = NA)
    
    phewas_res <- phewas_possibly(
      genotypes = genotype_masks %>% purrr::pluck("genotypes"),
      phenotypes = phecode_df,
      covariates = covariate_df,
      # additive.genotypes = additive,
      ...
    )

    dplyr::tibble(
      mask_name = mask_name,
      population = population,
      allele_counts = list(allele_counts),
      covariates = list(names(covariate_df %>% dplyr::select(-PMBB_ID))),
      phewas_res
    )
  }) %>%
    purrr::list_rbind()

  return(phewas_res_list)
}
```
  
```{r example-run_pmbb_phewas, eval=FALSE}
#' \dontrun{
# Run a PheWAS
cftr_phewas_res <- pmbbPheWASr::run_pmbb_phewas(
  mask_genotypes_list = cftr_mask_res,
  populations = c("ALL", "EUR", "AFR"),
  covariate_population_col = "Class",
  covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, starts_with("Genotype_PC")),
  phenotypes = left_join(pmbb_phecodes_df, pmbb_labs_df),
  covariates = pmbb_covariates_df
)
#' }
```
  
```{r tests-run_pmbb_phewas}
test_that("run_pmbb_phewas works", {
  expect_true(inherits(run_pmbb_phewas, "function"))

  testthat::skip_if(testthat:::on_ci() | testthat:::on_cran())

  cftr_mask_res <- pmbb_extract_genotype_masks(
    gene = "CFTR",
    annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
    gene_col = "Gene.refGene",
    masks = list(
      plof_lt_0.001 = list(ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", gnomAD_exome_ALL = "< 0.001"),
      p_lp_het_gt_10 = list(CLNSIG = "%in% c('Pathogenic', 'Pathogenic/Likely_pathogenic')", HET_REF_ALT_CTS = "> 10")
    ),
    mask_operator = list(
      plof_lt_0.001 = "burden",
      p_lp_het_gt_10 = "single"
    ),
    variant_id_col = ID,
    effect_allele_col = Alt,
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
  )

  pmbb_phecodes <- pmbb_format_phecodes(phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt")

  suppressWarnings(
    phewas_res <- run_pmbb_phewas(
      mask_genotypes_list = cftr_mask_res %>% head(2),
      phenotypes = pmbb_phecodes %>% dplyr::select(1:5) %>% head(100),
      covariates = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
      populations = c("ALL", "EUR"),
      covariate_population_col = "Class",
      covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC"))
    )
  )

  expect_true(inherits(phewas_res, "data.frame"))

  pnpla2_mask_res <- pmbb_extract_genotype_masks(
    gene = "PNPLA2",
    annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
    gene_col = "Gene.refGene",
    masks = list(
      PNPLA2_plof_het_gt_10 = list(Gene.refGene = "== 'PNPLA2'", ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", HET_REF_ALT_CTS = "> 10"),
      PNPLA2_intronic = list(Gene.refGene = "== 'PNPLA2'", Func.ensGene = "== 'intronic'")
    ),
    mask_operator = list(
      PNPLA2_plof_het_gt_10 = "single",
      PNPLA2_intronic = "burden"
    ),
    variant_id_col = ID,
    effect_allele_col = Alt,
    plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
    bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL"
  )

  suppressWarnings(
    phewas_res <- run_pmbb_phewas(
      mask_genotypes_list = pnpla2_mask_res,
      phenotypes = pmbb_phecodes %>% dplyr::select(1:5) %>% head(100),
      covariates = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
      populations = c("ALL", "EUR"),
      covariate_population_col = "Class",
      covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC"))
    )
  )

  expect_true(inherits(phewas_res, "data.frame"))
})
```


## Run a PheWAS and generate a report

The `run_pmbb_phewas_report` function is a wrapper around the `run_pmbb_phewas` function that generates an HTML report of the results.

```{r function-run_pmbb_phewas_report}
#' Run a PheWAS and generate a report in a single step
#'
#' This function is a wrapper around the `run_pmbb_phewas` function that additionally generates an HTML report of the results.
#'
#' @param report_output_path (Optional) File name and path were the report should be saved. If not provided the report will be saved to the current directory
#' @inheritParams run_pmbb_phewas
#' @inheritParams pmbb_extract_genotype_masks
#' @inheritParams render_pmbb_phewas_report
#'
#' @return A named list containing the paths to the output files
#'
#' @export
run_pmbb_phewas_report <- function(gene, annotation_file, gene_col, masks, mask_operator, variant_id_col, effect_allele_col, plink_bin, bfile, phenotypes, covariates, populations, covariate_population_col, covariate_cols, mask_output = NULL, phewas_output = NULL, report_output_path = NULL, ...) {
  # Extract genotypes for a series of masks
  mask_res <- pmbb_extract_genotype_masks(
    gene = gene,
    annotation_file = annotation_file,
    gene_col = gene_col,
    masks = masks,
    mask_operator = mask_operator,
    variant_id_col = {{ variant_id_col }},
    effect_allele_col = {{ effect_allele_col }},
    plink_bin = plink_bin,
    bfile = bfile
  )

  # Save the mask results to a file
  if (is.null(mask_output)) {
    # Use a temporary file if mask_output is not provided
    mask_output <- tempfile(fileext = ".rds")
  }
  saveRDS(mask_res, file = mask_output)

  # Run a PheWAS
  phewas_res <- run_pmbb_phewas(
    mask_genotypes_list = mask_res,
    phenotypes = phenotypes,
    covariates = covariates,
    populations = populations,
    covariate_population_col = {{ covariate_population_col }},
    covariate_cols = {{ covariate_cols }},
    ...
  )

  # Save the PheWAS results to a file
  if (is.null(phewas_output)) {
    # Use a temporary file if phewas_output is not provided
    phewas_output <- tempfile(fileext = ".rds")
  }
  saveRDS(phewas_res, file = phewas_output)

  # Collapse the gene names into a single string
  gene_names_collapsed <- glue::glue_collapse(gene, sep = "-")

  # Generate a timestamp for the output file name
  timestamp <- format(Sys.time(), "%Y%m%d_%H%M%S")

  # Generate the output file name with the timestamp and collapsed gene names
  output_file <- paste0(gene_names_collapsed, "_", "phewas_report_", timestamp, ".html")

  # Set the full output file path
  if (!is.null(report_output_path)) {
    output_file <- fs::path(report_output_path, output_file)
  }

  # Render the PheWAS report
  render_pmbb_phewas_report(
    mask_output = mask_output,
    phewas_output = phewas_output,
    output_file = output_file
  )

  # Return the paths to the saved mask, PheWAS results, and report files
  return(list(
    report_output_path = output_file,
    mask_output = mask_output,
    phewas_output = phewas_output
  ))
}
```
  
```{r example-run_pmbb_phewas_report, eval=FALSE}
#' \dontrun{
run_pmbb_phewas_report(
  gene = "CFTR",
  annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
  gene_col = "Gene.refGene",
  masks = list(
    plof_lt_0.001 = list(ExonicFunc.ensGene = "%in% c('stopgain', 'stoploss', 'frameshift substitution')", gnomAD_exome_ALL = "< 0.001"),
    p_lp_het_gt_10 = list(CLNSIG = "%in% c('Pathogenic', 'Pathogenic/Likely_pathogenic')", HET_REF_ALT_CTS = "> 10")
  ),
  mask_operator = list(
    plof_lt_0.001 = "burden",
    p_lp_het_gt_10 = "single"
  ),
  variant_id_col = ID,
  effect_allele_col = Alt,
  covariate_population_col = "Class",
  covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, dplyr::starts_with("Genotype_PC")),
  mask_output = "cftr_mask_results.rds", # Optional: Specify the output path for the mask results file
  phewas_output = "cftr_phewas_results.rds", # Optional: Specify the output path for the PheWAS results file,
  phenotypes = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt",
  covariates = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
  bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL",
  plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
  cores = 16
)

#' }
```
  
```{r tests-run_pmbb_phewas_report}
test_that("run_phewas_report works", {
  expect_true(inherits(run_pmbb_phewas_report, "function"))
})
```

## Render a report from pre-saved pheWAS output
    
```{r function-render_pmbb_phewas_report}
#' Render a PheWAS report from existing genotype mask and PheWAS output
#'
#' This function renders an HTML report from pre-saved genotype mask and PheWAS output files or R objects.
#'
#' @param mask_output Path to the saved genotype output for each mask or an R list object containing the output of [pmbbPheWASr::pmbb_extract_genotype_masks]
#' @param phewas_output Path to the saved PheWAS output dataframe or an R dataframe object containing the output of [pmbbPheWASr::run_pmbb_phewas]
#' @param output_file Full path to save the HTML report
#' @param template_path Optional path to a custom Quarto template file. If not provided, the default template will be used. This template should be a Quarto document with the necessary code to render the PheWAS report, and must be located in the top directory of the current project. An example template can be generated using: `usethis::use_template("combined_phewas_template.qmd", save_as = "combined_phewas_template.qmd", package = "pmbbPheWASr")`, which will be saved in the current working directory.
#' @param ... Additional named parameters to pass to the Quarto document
#'
#' @return The function renders an HTML report and returns silently
#'
#' @export
render_pmbb_phewas_report <- function(mask_output, phewas_output, output_file, template_path = NULL, ...) {
  # Check if mask_output is an R object
  if (is.list(mask_output)) {
    temp_mask_file <- tempfile(fileext = ".rds")
    saveRDS(mask_output, temp_mask_file)
    mask_output <- temp_mask_file
  }

  # Check if phewas_output is an R object
  if (is.data.frame(phewas_output)) {
    temp_phewas_file <- tempfile(fileext = ".rds")
    saveRDS(phewas_output, temp_phewas_file)
    phewas_output <- temp_phewas_file
  }

  if (!is.null(template_path)) {
    if (!file.exists(template_path)) {
      cli::cli_abort("{.arg {template_path}} does not exist. Please provide a valid path to a Quarto template file.")
    }
  } else {
    cli::cli_alert_info("No results template provided. Using default template.")
    template_path <- ".combined_phewas_template.qmd"
    usethis::use_template(template = "combined_phewas_template.qmd", save_as = template_path, package = "pmbbPheWASr")
  }

  if (!file.exists(mask_output)) {
    cli::cli_abort("{.arg {mask_output}} does not exist. Please provide a valid path to a genotype mask results file.")
  }

  if (!file.exists(phewas_output)) {
    cli::cli_abort("{.arg {phewas_output}} does not exist. Please provide a valid path to a PheWAS results file.")
  }

  quarto::quarto_render(
    input = template_path,
    output_format = "html",
    execute_params = list(
      mask_results = fs::path_abs(mask_output),
      phewas_results = fs::path_abs(phewas_output),
      ...
    ),
    output_file = basename(output_file)
  )

  fs::dir_create(fs::path_dir(output_file))

  fs::file_move(basename(output_file), output_file)

  if (file.exists(".combined_phewas_template.qmd")) {
    fs::file_delete(".combined_phewas_template.qmd")
  }

  # Return the path to the generated report file
  cli::cli_alert_success("PheWAS report rendered successfully: {.val {output_file}}")
}
```
  
```{r example-render_pmbb_phewas_report, eval=FALSE}
#' \dontrun{
render_pmbb_phewas_report(
  phewas_output = cftr_phewas_res,
  mask_output = cftr_mask_res,
  output_file = "CFTR_pheWAS_report.html"
)
#' }
```
  
```{r tests-render_pmbb_phewas_report}
test_that("render_pmbb_phewas_report works", {
  expect_true(inherits(render_pmbb_phewas_report, "function"))

  skip()
  render_pmbb_phewas_report(
    phewas_output = "/project/damrauer_shared/Users/mglevin/pmbbPheWASr/tests/testthat/cftr_phewas_results.rds",
    mask_output = "/project/damrauer_shared/Users/mglevin/pmbbPheWASr/tests/testthat/cftr_mask_results.rds",
    output_file = "cftr_report.html"
  )
})
```
  


<!--
# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_pmbb_phewas.Rmd", vignette_name = NA)
```
