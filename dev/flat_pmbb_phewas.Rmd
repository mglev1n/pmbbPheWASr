---
title: "PMBB Phenome-wide Association Studies"
output: html_document
editor_options: 
  chunk_output_type: console
---

<!-- Run this 'development' chunk -->
<!-- Store every call to library() that you need to explore your functions -->

```{r development, include=FALSE}
library(testthat)
```

<!--
 You need to run the 'description' chunk in the '0-dev_history.Rmd' file before continuing your code there.

If it is the first time you use {fusen}, after 'description', you can directly run the last chunk of the present file with inflate() inside.
--> 

```{r development-load}
# Load already included functions if relevant
pkgload::load_all(export_all = FALSE)
```

<!-- 
 Store your dataset in a directory named "inst/" at the root of your project.
 Use it for your tests in this Rmd thanks to `pkgload::load_all()` to make it available
and `system.file()` to read it in your examples.

- There already is a dataset in the "inst/" directory to be used in the examples below
-->

```{r development-dataset, eval=FALSE}
# Run all this chunk in the console directly
# There already is a dataset in the "inst/" directory
# Make the dataset file available to the current Rmd during development
pkgload::load_all(path = here::here(), export_all = FALSE)
# 
# # You will be able to read your example data file in each of your function examples and tests as follows - see chunks below
# datafile <- system.file("nyc_squirrels_sample.csv", package = "pmbbPheWASr")
# nyc_squirrels <- read.csv(datafile, encoding = "UTF-8")
# 
# nyc_squirrels
```


# Filter Variant Annotations File

The `awk_str_filter` function can be used to filter arbitrary rows from a tab-delimited text file using `awk`. The function accepts the path to a tab-delimited text file, name of a column to filter, and the string to filter for. The function returns a tibble containing the filtered rows. This function can be used to filter the PMBB variant annotations file to only include variants within the specified gene(s).
    
```{r function-awk_str_filter}
#' Filter arbitrary rows from a tab-delimited text file using awk
#'
#' This function wraps the system command `awk` to efficiently filter rows from a tab-delimited text file. The function accepts the path to a tab-delimited text file, name of a column to filter, and the string to filter for. The function returns a tibble containing the filtered rows.
#'
#' @param filename The path to the tab-delimited text file.
#' @param filter_col The name of the column to filter.
#' @param filter_str A character vector of strings to filter for in the specified column.
#'
#' @return
#'
#' A [tibble::tibble()] containing the filtered rows from the input file
#'
#' @export
#'
awk_str_filter <- function(filename, filter_col, filter_str) {
    # Check if the file exists
    if (!file.exists(filename)) {
        cli::cli_abort("File does not exist: {filename}")
    }
    
    cli::cli_progress_step("Extracting '{filter_str}' from column '{filter_col}' in {.file {filename}}")
  
    # Determine the column index based on the filter_col
    header <- readLines(filename, n = 1)
    col_names <- strsplit(header, "\t")[[1]]
    col_index <- which(col_names == filter_col)

    if (length(col_index) == 0) {
        cli::cli_abort("Column not found: {filter_col}")
    }

    # Construct the awk command
    # awk_cmd <- paste0("awk -F'\t' '", paste0("$", col_index, " ~ /", paste(filter_str, collapse = "|"), "/"), "' ", shQuote(filename))
    
    awk_cmd <- c(paste0("NR == 1 || ", paste0("($", col_index, " == \"", filter_str, "\")", collapse = " || ")), filename)
    
    # Execute the awk command using processx
    result <- processx::run(
        command = "awk",
        args = awk_cmd,
        error_on_status = TRUE
    )

    # Check if the command executed successfully
    if (result$status != 0) {
        cli::cli_abort("Error executing awk command: {result$stderr}")
    }

    # Format the filtered output using data.table::fread()
    filtered_dt <- data.table::fread(
        text = result$stdout,
        sep = "\t",
        header = FALSE,
        stringsAsFactors = FALSE,
        quote = "",
        colClasses = rep("character", length(col_names))
    )

    # Convert the data.table to a tibble
    filtered_tibble <- tibble::as_tibble(filtered_dt)

    return(filtered_tibble)
}

```
  
```{r example-awk_str_filter}
awk_str_filter(filename = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
               filter_col = "Gene.refGene",
               filter_str = c("LDLR", "PCSK9"))
```
  
```{r tests-awk_str_filter}
test_that("awk_str_filter works", {
  res <- awk_str_filter(filename = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
               filter_col = "Gene.refGene",
               filter_str = c("LDLR"))
  expect_true(inherits(awk_str_filter, "function")) 
  expect_true(tibble::is_tibble(res))
})
```
  

<!--
# There can be development actions

Create a chunk with 'development' actions

- The chunk needs to be named `development` or `dev`
- It contains functions that are used for package development only
- Note that you may want to store most of these functions in the 0-dev_history.Rmd file

These are only included in the present flat template file, their content will not be part of the package anywhere else.
-->

```{r development-inflate, eval=FALSE}
# Keep eval=FALSE to avoid infinite loop in case you hit the knit button
# Execute in the console directly
fusen::inflate(flat_file = "dev/flat_pmbb_phewas.Rmd", vignette_name = "Get started")
```

