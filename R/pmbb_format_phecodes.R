# WARNING - Generated by {fusen} from dev/flat_pmbb_phewas.Rmd: do not edit by hand

#' Format covariate data for PheWAS
#'
#' This function reads and processes covariate files for use in PheWAS analysis.It checks if the specified covariate files exist, reads them, and performs the necessary data formatting and validation. If multiple files are specified they will be joined together from left-to-right, keeping duplicated columns from the left-most file.
#'
#' @param covariate_files Path to PMBB covariate file(s) used to run PheWAS. If multiple files are provided, they will be joined by `PMBB_ID`, and values for duplicated columns will be preserved from the from the file that is specified earlier.
#' @param covariate_cols Vector of columns in the covariate file that should be used as covariates in the PheWAS
#' @param covariate_population_col Column containing population labels in the covariate file, required if `populations` is not `"ALL"`
#' @param populations A character vector of populations to run PheWAS on. Default is `c("ALL")`

#' @family {phenotypes}
#' @return A formatted covariate dataframe with selected columns and unique PMBB_IDs.
#'
#' @noRd
#' @examples
#' \dontrun{
#' pmbb_covariates_df <- pmbbPheWASr:::pmbb_format_covariates(
#'   covariate_files = c("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_covariates.txt", "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.1/PMBB-Release-2020-2.1_phenotype_covariates.txt"),
#'   populations = c("ALL", "EUR"),
#'   covariate_population_col = Class,
#'   covariate_cols = c(Age = Age_at_Enrollment, Sex = Gen_Sex, starts_with("Genotype_PC"))
#' )
#' }

pmbb_format_covariates <- function(covariate_files, covariate_cols, covariate_population_col, populations) {
  # Check if covariates exists - this may include multiple files
  covariates_exists <- purrr::map(covariate_files, file.exists) %>%
    unlist()

  if (FALSE %in% purrr::map(covariate_files, file.exists)) {
    missing_covariates_files <- covariate_files[!covariates_exists]
    cli::cli_abort("{missing_covariates_files} does not exist")
  }

  # Check if populations is a character vector
  if (!is.character(populations)) {
    cli::cli_abort("{.arg populations} must be a character vector")
  }

  # Check if populations contains values other than "ALL"
  populations <- unique(populations)
  if (length(sum(stringr::str_detect(populations, "ALL"))) / length(populations) != 1) {
    if (rlang::quo_is_null(rlang::enquo(covariate_population_col))) {
      cli::cli_abort("{.arg covariate_population_col} must be provided if {.arg populations} contains values other than {.val ALL}")
    }
  }

  cli::cli_progress_step("Reading covariate file(s): {covariate_files}")

  covariate_df <- purrr::map(covariate_files, \(x) vroom::vroom(x, show_col_types = FALSE) %>% unique()) %>%
    purrr::reduce(dplyr::left_join, by = c("PMBB_ID"), suffix = c("", "_duplicated")) %>%
    dplyr::select(-tidyselect::ends_with("_duplicated")) %>%
    unique()

  if (!rlang::quo_is_null(rlang::enquo(covariate_population_col))) {
    # TODO need better checking that the covariate_population_col is in the covariate_df

    covariate_populations <- unique(covariate_df %>% dplyr::pull({{ covariate_population_col }}))
    missing_populations <- setdiff(populations, covariate_populations)
    missing_populations <- purrr::discard(missing_populations, function(x) x == "ALL")

    if (length(missing_populations > 0)) {
      cli::cli_abort("Population(s) {.val {missing_populations}} not found in covariate file")
    }

    cli::cli_alert_info("All populations were found in the covariates file")
  }

  covariate_df %>%
    dplyr::select(PMBB_ID, {{ covariate_cols }}, !!rlang::ensym(covariate_population_col)) %>%
    assertr::assert(assertr::is_uniq, PMBB_ID)
}

#' Format labs data for PheWAS
#'
#' This function will read in labs data from PMBB and format it for use in a PheWAS. By default, this function will return a data frame with summary measures (`min`, `median`, `mean`, `max`) of each lab value for each individual in the PMBB cohort. Because PMBB lab data is only roughly cleaned, the function will by default select only the most common `RESULT_NAME` for each lab test.

#'
#'
#' @param labs_files A character vector of file paths to the labs data
#' @param patient_class A character vector of patient classes (location of lab testing) to include in the analysis. Default is `"Outpatient"`
#'
#' @return A [tibble::tibble()] containing `PMBB_ID` and summary measures of lab values for each PMBB participant
#' @import duckdb dbplyr
#'
#' @family {phenotypes}
#' @export
#' @examples
#' \dontrun{
#' pmbb_labs_df <- fs::dir_ls("/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/", glob = "*labs*", recurse = TRUE) %>%
#'   pmbb_format_labs()
#' }

pmbb_format_labs <- function(labs_files, patient_class = "Outpatient") {
  rlang::arg_match(patient_class, c("Inpatient", "Outpatient"))

  cli::cli_progress_step("Processing labs data: {.val {labs_files}}")

  # TODO add fuzzy matching for lab names
  # if(fuzzy) {
  # lab_counts_df <- arrow::open_tsv_dataset(labs_files) %>%
  #   dplyr::select(PMBB_ID, PATIENT_CLASS, RESULT_NAME, RESULT_VALUE_NUM) %>%
  #   dplyr::filter(PATIENT_CLASS %in% patient_class) %>%
  #   dplyr::mutate(file = add_filename()) %>%
  #   # head(1000) %>%
  #   dplyr::compute() %>%
  #   arrow::to_duckdb() %>%
  #   dplyr::group_by(file, RESULT_NAME) %>%
  #   dplyr::summarize(n = n(), .groups = "drop") %>%
  #   dplyr::group_by(file) %>%
  #   dplyr::arrange(desc(n), .by_group = TRUE) %>%
  #   dplyr::ungroup() %>%
  #   dplyr::filter(n > min_records) %>%
  #   dplyr::collect()
  #
  # lab_counts_df <- lab_counts_df %>%
  #   dplyr::group_by(file) %>%
  #   dplyr::slice_max(n) %>%
  #   dplyr::ungroup() %>%
  #   dplyr::mutate(lead_result_name = stringr::str_to_lower(RESULT_NAME)) %>%
  #   dplyr::select(lead_result_name) %>%
  #   fuzzyjoin::stringdist_left_join(lab_counts_df %>% dplyr::mutate(result = stringr::str_to_lower(RESULT_NAME)), by = c("lead_result_name" = "result"), method = "jw", max_dist = 0.4)
  #
  # return(lab_counts_df)
  #
  # }

  arrow::open_tsv_dataset(labs_files) %>%
    dplyr::select(PMBB_ID, PATIENT_CLASS, RESULT_NAME, RESULT_VALUE_NUM) %>%
    dplyr::filter(PATIENT_CLASS %in% patient_class) %>%
    dplyr::mutate(file = add_filename()) %>%
    # head(1000) %>%
    dplyr::compute() %>%
    arrow::to_duckdb() %>%
    dplyr::add_count(RESULT_NAME) %>%
    dplyr::group_by(file) %>%
    dplyr::slice_max(n) %>%
    dplyr::collect() %>%
    dplyr::group_by(PMBB_ID, RESULT_NAME) %>%
    dplyr::summarise(across(RESULT_VALUE_NUM, list(min = min, median = median, mean = mean, max = max), .names = "{.fn}"), .groups = "drop") %>%
    # dplyr::ungroup() %>%
    tidytable::pivot_wider(
      id_cols = PMBB_ID,
      names_from = RESULT_NAME,
      values_from = c(min, median, mean, max),
      names_glue = "{RESULT_NAME}_{.value}"
    ) %>%
    dplyr::ungroup() %>%
    dplyr::rename_with(janitor::make_clean_names, .cols = -PMBB_ID) %>%
    tibble::as_tibble()
}

#' Format PMBB phecode data
#'
#' Given a dataframe containing PMBB phecodes, apply a case treshold for categorizing individuals as cases or controls
#'
#' @param phecode_file Path to PMBB phecode file used to run PheWAS
#' @param phecode_case_threshold Number of cases required to classify an individual as a case
#'
#' @return A [tibble::tibble()] containing `PMBB_ID` and phecodes as columns, with TRUE/FALSE values for each phecode column

#' @family {phenotypes}
#' @export
#' @examples
#' \dontrun{
#' pmbb_phecodes_df <- pmbb_format_phecodes(phecode_file = "/project/PMBB/PMBB-Release-2020-2.0/Phenotype/2.3/PMBB-Release-2020-2.3_phenotype_PheCode-matrix.txt", phecode_case_threshold = 2)
#' }

pmbb_format_phecodes <- function(phecode_file, phecode_case_threshold = 2) {
  cli::cli_progress_step("Formatting {phecode_file}")

  vroom::vroom(phecode_file, show_col_types = FALSE) %>%
    tidytable::pivot_longer(cols = c(-PMBB_ID)) %>%
    tibble::as_tibble() %>%
    dplyr::mutate(case = dplyr::if_else(value >= phecode_case_threshold, TRUE, FALSE)) %>%
    tidytable::select(PMBB_ID, name, case) %>%
    tidytable::pivot_wider(names_from = name, values_from = case, values_fill = FALSE) %>%
    tibble::as_tibble() %>%
    # unique() %>%
    assertr::assert(assertr::is_uniq, PMBB_ID)
}
