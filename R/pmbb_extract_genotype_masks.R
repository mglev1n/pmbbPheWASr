# WARNING - Generated by {fusen} from dev/flat_pmbb_phewas.Rmd: do not edit by hand

#' Extract genotypes based on variant masks
#' 
#' This function extracts genotypes for a subset of participants based on a set of masks. It wraps `awk_str_filter`, `apply_variant_masks`, and `pmbb_extract_genotypes` to extract genotypes for PMBB participants based on a set of masks.
#' 
#' @param annotation_file The path to the variant annotation file.
#' @param gene The name of the gene to filter variants for.
#' @param gene_col The name of the column in the annotation file to filter the gene on.
#' @param masks A named list of lists containing filter criteria for each mask.
#'   Each element of the outer list should be named after the desired output name for the filtered data frame (eg. name of the variant mask).
#'   Each inner list should contain the filter criteria for a specific set of columns.
#'   For example: list(plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"), common_0.01 = list(gnomAD_exome_ALL = "> 0.01"))
#' @param variant_id_col The name of the column in the annotation file that contains the variant IDs.
#' @param effect_allele_col The name of the column in the annotation file that contains the effect alleles.
#' @param mask_operator A named list specifying the operation to perform for each mask. Valid operations are "burden" (default) and "single".
#'   The names in the mask_operator list should correspond to the names in the masks list.
#'   For example: list(plof_0.001 = "burden", common_0.01 = "single")
#' @param plink_bin The path to the `plink2` binary executable.
#' @param bfile The prefix of the plink binary files (without the file extension).
#' @param threads The number of threads to use for parallel processing (default: 1).
#' @param memory The amount of memory (in MB) to allocate for `plink2` (default: 8000).
#' 
#' @return A named list, where each element represents a mask and contains a list with components based on the specified mask_operator:
#'        - If mask_operator is "burden" (default):
#'          - "variants": A [tibble::tibble()] of the variants included in the mask.
#'          - "genotypes": A [tibble::tibble()] containing the genotype for each PMBB participant.
#'          - "mask_type": A [tibble::tibble()] containing the mask type applied (eg. "burden" or "single")
#' @export
#' @examples
#' \dontrun{
#' ldlr_mask_res <- pmbb_extract_genotype_masks(
#'   gene = "LDLR",
#'   annotation_file = "/project/PMBB/PMBB-Release-2020-2.0/Exome/Variant_annotations/PMBB-Release-2020-2.0_genetic_exome_variant-annotation-counts.txt",
#'   gene_col = "Gene.refGene",
#'   masks = list(
#'     plof_0.001 = list(ExonicFunc.ensGene = "== 'stopgain'", gnomAD_exome_ALL = "< 0.001"),
#'     rare_0.000001 = list(gnomAD_exome_ALL = "< 0.000001")
#'   ),
#'   mask_operator = list(
#'     plof_0.001 = "burden",
#'     rare_0.000001 = "single"
#'   ),
#'   variant_id_col = ID,
#'   effect_allele_col = Alt,
#'   plink_bin = "/project/voltron/Applications/PLINK/plink2_linux_avx2_20230607/plink2",
#'   bfile = "/project/PMBB/PMBB-Release-2020-2.0/Exome/pVCF/all_variants/PMBB-Release-2020-2.0_genetic_exome_GL")
#' }

pmbb_extract_genotype_masks <- function(gene, annotation_file, gene_col, masks, variant_id_col, effect_allele_col, mask_operator = NULL, plink_bin, bfile, threads = 1, memory = 8000) {
    
    # Check if the names in the mask_operator list are present in the masks list
    if (!is.null(mask_operator) && !all(names(mask_operator) %in% names(masks))) {
      missing_masks <- setdiff(names(mask_operator), names(masks))
      cli::cli_abort("The following mask operators are not present in the masks list: {missing_masks}")
    }
    
    cli::cli_progress_step("Filtering variants for gene: {.val {gene}}")
    
    gene_variants <- awk_str_filter(
      filename = annotation_file,
      filter_col = gene_col, 
      filter_str = gene
    )
    
    cli::cli_progress_step("Applying variant masks")
    
    masked_variants <- apply_variant_masks(gene_variants, masks)
    
    cli::cli_progress_step("Extracting unique set of variant IDs across all masks")
    
    unique_variant_ids <- masked_variants %>%
      purrr::map(~ dplyr::pull(.x, {{ variant_id_col }})) %>%
      purrr::reduce(union)
    
    cli::cli_progress_step("Extracting genotypes for unique set of variant IDs")
    
    genotype_df <- pmbb_extract_genotypes(
      variant_df = gene_variants %>% dplyr::filter({{ variant_id_col }} %in% unique_variant_ids),
      variant_id_col = {{ variant_id_col }},
      effect_allele_col = {{ effect_allele_col }},
      plink_bin = plink_bin,
      bfile = bfile,
      threads = threads,
      memory = memory
    )
    
    cli::cli_progress_step("Processing genotypes for each variant mask")
    
    mask_list <- purrr::imap(masked_variants, function(variant_df, mask_name) {
      mask_genotypes <- genotype_df %>%
        dplyr::mutate(ID = stringr::str_replace(variant_id, "_[^_]+$", "")) %>%
        dplyr::filter(ID %in% (variant_df %>% dplyr::pull({{ variant_id_col }})))
      
      if (is.null(mask_operator) || mask_operator[[mask_name]] == "burden") {
        mask_genotypes_summarized <- mask_genotypes %>%
          dplyr::group_by(PMBB_ID) %>%
          dplyr::summarize(genotype = sum(genotype, na.rm = TRUE), .groups = "drop") %>%
          dplyr::select(dplyr::everything(), genotype)
        
        list(variants = variant_df %>% filter({{ variant_id_col }} %in% mask_genotypes$ID),
             genotypes = mask_genotypes_summarized,
             mask_type = "burden")
        
      } else if (mask_operator[[mask_name]] == "single") {
        purrr::map(unique(mask_genotypes$variant_id), function(variant) {
          variant_genotypes <- mask_genotypes %>% 
            dplyr::filter(variant_id == variant) %>%
            dplyr::select(dplyr::everything(), genotype)
          
          list(
            name = paste(mask_name, variant, sep = "_"),
            variants = variant_df %>% dplyr::filter({{ variant_id_col }} == stringr::str_replace(variant, "_[^_]+$", "")),
            genotypes = variant_genotypes,
            mask_type = "single"
          )
        })
      }
    })
    
    # Set the names of the mask_list for burden masks
    burden_mask_names <- names(mask_operator)[mask_operator == "burden"]
    names(mask_list)[names(mask_list) %in% burden_mask_names] <- burden_mask_names
    
    # Flatten the single-variant masks and set their names
    single_mask_list <- purrr::flatten(mask_list[names(mask_list) %in% names(mask_operator)[mask_operator == "single"]])
    names(single_mask_list) <- purrr::map_chr(single_mask_list, "name")
    single_mask_list <- purrr::map(single_mask_list, ~ purrr::keep(.x, names(.x) %in% c("variants", "genotypes", "mask_type")))
    
    # Combine the burden and single-variant masks into the final mask_list
    final_mask_list <- c(mask_list[names(mask_list) %in% burden_mask_names], single_mask_list)
    
    return(final_mask_list)
}
